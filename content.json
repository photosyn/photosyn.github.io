{"meta":{"title":"photosyn's blog","subtitle":"keep learning","description":"学习，生活","author":"photosyn","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2019-01-08T02:59:42.000Z","updated":"2019-01-08T03:00:35.841Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ble基础与ble协议栈","slug":"ble-theory","date":"2019-01-03T03:15:22.000Z","updated":"2019-01-08T06:22:53.992Z","comments":true,"path":"2019/01/03/ble-theory/","link":"","permalink":"http://yoursite.com/2019/01/03/ble-theory/","excerpt":"标准蓝牙(Classic Bluetooth)与低功耗蓝牙(Bluetooth Low Energy) 低功耗蓝牙搜索、连接的速度更快 低功耗蓝牙功耗要求低","text":"标准蓝牙(Classic Bluetooth)与低功耗蓝牙(Bluetooth Low Energy) 低功耗蓝牙搜索、连接的速度更快 低功耗蓝牙功耗要求低 低功耗蓝牙传输速度慢，数据量小 低功耗蓝牙是从蓝牙4.0标准开始 BLE协议栈介绍工作中使用的是CC2540、CC2541，所以以TI BLE协议栈为例： BLE协议采用分层设计，简单描述各层的主要功能： PHY：BLE的市场定位是个体和民用，使用的是免费的ISM频段（频率范围是2.400-2.4835 GHz）。BLE将整个频带分为40份，每份的带宽为2MHz，称作RF Channel。物理层定义的就是这部分通信介质以及RF发射相关的特性,包括发射功率（Transmission power）、调制方式（Modulation）等等。 LL：支持设备间物理无关的逻辑传输通道，包括逻辑通道的定义（广播通道和非广播通道），通道选择用到的调频技术（Hopping），控制设备的射频状态（等待、广播、扫描、发起连接、已连接）和角色（主机、从机），控制数据包发送时机、完整性、ACK接收等。 HCI：为主机和控制器提供统一的通信接口，这一层可以是软件API或硬件外设UART SPI USB。 L2CAP：通道的多路复用，上层数据的分割和重组，生成协议数据单元(PDUs)，，满足用户数据传输对延时的要求和对连接间隔的管理。 SM：定义配对与密钥分配方式，并为协议栈其他层与另一个设备之间的安全连接和数据交换提供服务。 ATT：ATT层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据。BLE引入了attribute概念，用来描述一条一条的数据。Attribute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层。 GAP：负责处理设备的访问模式和程序。包括定义蓝牙设备角色(Broadcaster Role/Observer Role/Peripheral Role/Central Role)和通信操作模式和过程(Broadcast mode and observation procedure/Discovery modes and procedures/Connection modes and procedures/Bonding modes and procedures)，定义蓝牙地址、蓝牙名称等和蓝牙相关的参数。 GATT：GATT用来规范attribute中的数据内容，并运用group（分组）的概念对attribute进行分类管理。正是因为有了GATT和各种各样的应用profile，BLE摆脱了ZigBee等无线协议的兼容性困境。 Application：包括Gap Role/Security Profiles和GATT Profiles，应用层可以包含多个GATT Profiles。 链路层角色介绍BLE设备在LL层定义了两个角色Master和Slave。 Master是连接的发起方（Initiator），可以决定和连接有关的参数 Slave是连接的接受方（Advertiser），可以请求（或建议）连接参数，但无法决定。 链路层状态机介绍通过上面LL层角色的介绍，引出了LL层的状态机： Standby（就绪态）Standby状态是初始状态，即不发送数据，也不接收数据。根据上层实体的命令（如位于host软件中GAP），可由其它任何一种状态进入，也可以切换到除Connection状态外的任意一种状态。 Advertising（广播态）Advertising状态是可以通过广播通道发送数据的状态，由Standby状态进入。它广播的数据可以由处于Scanning或者Initiating状态的实体接收。上层实体可通过命令将Advertising状态切换回Standby状态。另外，连接成功后，也可切换为Connection状态。 Scanning（扫描态）Scanning状态是可以通过广播通道接收数据的状态，由Standby状态进入。根据Advertiser所广播的数据的类型，有些Scanner还可以主动向Advertiser请求一些额外数据。上层实体可通过命令将Scanning状态切换回Standby状态。 Initiating（发起态）Initiating状态和Scanning状态类似，不过是一种特殊的接收状态，由Standby状态进入，只能接收Advertiser广播的connectable的数据，并在接收到数据后，发送连接请求，以便和Advertiser建立连接。当连接成功后，Initiater和对应的Advertiser都会切换到Connection状态。 Connection（连接态）Connection状态是和某个实体建立了单独通道的状态，在通道建立之后，由Initiating或者Advertising自动切换而来。通道断开后，会重新回到Standby状态。 数据传输格式LL层的状态切换和角色都了解之后，再看数据如何传输。 在BLE的LL层，数据传输是和数据的状态相关的，而五个状态在PHY层被分为两种类型的Physical Channel（advertising channel和data channel）。 Advertising、Scanning、Initiating这三种状态下的通信属于advertising channel。Connection状态下的通信属于data channel。Standby状态不参与通信，因此没有对应的PHY层Channel。 LL层虽然存在多种状态，但都遵循统的数据传输格式： Preamble：前导是一个8比特的交替序列。他不是01010101就是10101010，取决于接入地址的第一个比特。若接入地址的第一个比特为0：01010101。若接入地址的第一个比特为1：10101010。接收机可以根据前导的无线信号强度来配置自动增益控制。 Access Address：接入地址有两种类型：广播接入地址和数据接入地址。广播接入地址：固定为0x8E89BED6，在广播、扫描、发起连接时使用。数据接入地址：随机值，不同的连接有不同的值。在连接建立之后的两个设备间使用。对于数据信道，数据接入地址是一个随机值，但需要满足下面几点要求： 数据接入地址不能超过6个连续的“0”或“1”。 数据接入地址的值不能与广播接入地址相同。 数据接入地址的4个字节的值必须互补相同。 数据接入地址不能有超24次的比特翻转(比特0到1或1到0，称为1次比特翻转)。 数据接入地址的最后6个比特需要至少两次的比特翻转。 符合上面条件的有效随机数据接入地址大概有231个。 PDU（Packet Data Unit）：协议数据单元在BLE的LL层不同状态下的字段定义不同，PDU长度最大为257 octets，我们后面详细描述。 CRC：BLE采用的是24位CRC校验。CRC对报头、长度和数据进行计算。 下面从两种Physical Channel（advertising channel和data channel）中，我们各选择一个状态模式下的传输数据的例子，有了大概的概念之后，再学习PDU的详细内容。 例子参考了这篇文章：：https://www.cnblogs.com/iini/p/8969828.html 这篇文章由例子出发，描述了packet format的一些设计思路。由于文章比较长，这里精简了一些方便记忆。 广播态数据传输例子以广播态下的通信包为例（小端模式），发送一个电量数据0x53： AA - 前导（为了调制解调电路工作更高效） D6BE898E - 接入地址，广播模式下固定为0x8E89BED6。 60 – LL帧头字段(表示LL数据包类型) 0E – 有效数据包长度(表示LL帧中实际payload的长度) 3B75AB2A02E1 – 广播者设备地址(用于确定数据包是谁广播的) 02010504FF590053 – 广播数据（0x02-长度，0x01-广播类型，0x05-值，0x04-自定义数据类型长度，0xFF-自定义数据类型，0x0059-供应商ID，0x53-电量数据） 8EC7B2 – CRC24值（数据校验） 广播数据包的限制： 无法进行一对一双向通信 （广播是一对多通信，而且是单方向的通信） 由于不支持组包和拆包，因此无法传输大数据 通信不可靠及效率低下。广播信道不能太多，否则将导致扫描端效率低下。为此，BLE只使用37(2402MHz) /38(2426MHz) /39(2480MHz)三个信道进行广播和扫描，因此广播不支持跳频。由于广播是一对多的，所以广播也无法支持ACK。这些都使广播通信变得不可靠。 扫描端功耗高。由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对37/38/39三个通道进行扫描，这样功耗就会比较高。 连接态数据传输例子 AA – 前导（为了调制解调电路工作更高效） 50655DAB – 接入地址，连接模式下生成一个独特的随机访问地址 1E – LL帧头字段(表示LL数据包类型) 08 – 有效数据包长度(表示LL帧中实际payload的长度) 04000400 – ATT数据长度（0x0004），以及L2CAP通道编号（0x0004） 1B – 命令类型（读/写/notify/indicate） 0013 – 数据类型 53 – 真正要发送的电量数据 F650D5 – CRC24值 连接过程会同步时钟，而且同步后射频收发窗口都可以很短，因此连接后的数据通信效率大大提高。 advertising channel对应的PDU通过上面两个例子，可以看出在不同LL层状态下PDU的定义不同。 先看Advertising、Scanning、Initiating这三种状态，也就是对应的advertising channel的基本PDU格式： PDU Type：指示PDU的类型，具体参考后面的介绍。 RFU：保留。 TxAdd、RxAdd：由具体的PDU Type决定其意义。 Length：PDU的长度，6 bits，有效范围是6~37 octets。 Advertising（广播态）通信 Packet Sniffer抓取的ADV_IND类型的PDU广播数据包示例： Advertising Channel的选择BLE可以使用40个Physical Channel中的3个作为广播通信的物理信道，综合各种因素（抗干扰等），最终选取了如下三个： RF Channel RF Center Frequency Advertising Channel Index 0 2402MHz 37 12 2426MHz 38 39 2480MHz 39 与此同时，LL层允许Host在这这三个物理信道中，任意选取一个或者多个，用于广播。LL层将相同的广播数据，在每一个被中的Channel中，发送一次。 Advertising Event的定义BLE广播的过程中，根据使用场景的不同，会在被使用的每一个物理Channel上，发送（或接收）多种类型的PDU。基于此，BLE协议提出了“Advertising Event”的概念，即： Advertising Event是在所有被使用的物理Channel上，发送的Advertising PDU的组合。 可以通俗的理解为：BLE设备处于Advertising状态的目的，就是要广播数据。并且，根据应用场景的不同，可广播4种类型的数据。另外，BLE设备最多可以在3个物理Channel上广播数据。也就是说，同一个数据（4中类型中的一种），需要在多个Channel上依次广播。因此，这样依次在多个Channel上广播的过程，就叫做一个Advertising Event。与此同时，有些广播（如可连接、可扫描）发送出去之后，允许接收端在对应的Channel上，回应一些请求（如连接请求、扫描请求）。并且，广播者接收到扫描请求后，需要在同样的Channel上回应。这些过程，也会计算在一个Advertising Event中。 Advertising Event Type根据应用场景的不同，BLE协议也规定了不同类型的Advertising Event，包括： Connectable Undirected Event； Connectable Directed Event（包括Low Duty Cycle和High Duty Cycle）； Scannable Undirected Event； Non-connectable Undirected Event。 不同的Advertising Event，所对应的Advertising参数（如周期等）不同。 Advertising周期的设定对BLE广播通信来说，Advertising的周期是一个比较重要的参数，因为它关系到系统的功耗和通信的效率，因此需要根据使用场景，小心设定。Advertising周期主要由advInterval、advDelay两个参数决定的，如下图所示： advInterval是一个可由Host设定的参数：对于Scannable Undirected和Non-connectable Undirected两种Advertising Event，该值不能小于100ms（从功耗的角度考虑的，也决定了广播数据的速率）；对于Connectable Undirected和Low Duty Cycle Connectable Directed两种Advertising Event，该值不能小于20ms。 advDelay则是一个0~10ms的伪随机数。 High Duty Cycle Connectable Directed Event的Advertising周期不受上面的参数控制，可以小到3.75ms。不过呢，BLE协议也同时规定：LL必须在1.28s内退出这种状态。 注1：我们可以从上面的时间信息推断出，BLE协议对广播通信的期望，是非常明确的—-不在乎速率、只在乎功耗。一般的广播通信（不以连接为目的），最高速率也就是31byte / 100ms = 2.48kbps。如果再算上可扫描的那段数据，也就是double，4.96kbps。 注2：对于连接来说，如果事先不知道连接发起者的设备地址，则最快的连接速度可能是20ms。如果事先知道地址，使用High Duty Cycle Connectable Directed Event的话，则可能在3.75ms内建立连接。由此可以看出，BLE的连接建立时间，比传统蓝牙少了很多，这也是BLE设备之间不需要保持连接的原因。 Scanning（扫描态）通信下面是扫描态的PDU定义： Packet Sniffer抓取的ADV_SCAN_REQ类型的PDU广播数据包示例： scanWindow和scanIntervalScanning状态扫描、接收广播数据的状态，该状态的扫描行为是由scanWindow和scanInterval两个参数决定的。scanWindow指示一次扫描的时间（即可以理解为RF RX打开的时间），scanInterval指示两次扫描之间的间隔。如果这两个参数的值相同，表示连续不停地扫描。 BLE协议规定，scanWindow和scanInterval最大不能超过10.24s，并且scanWindow不能大于scanInterval。 Passive Scanning和Active ScanningPassive Scanning这种扫描模式下，BLE设备只听不问，也就是说，只接收ADV_DIRECT_IND、ADV_IND、ADV_SCAN_IND、ADV_NONCONN_IND等类型的PDU，并不发送SCAN_REQ。 而Active Scanning扫描模式，不只认真听讲，还勤于发问（SCAN_REQ），并接收后续的 SCAN_RSP。 这两种Scanning的最终结果，就是把接收到的数据（包括Advertiser地址、Advertiser数据等），反馈给Host。 Initialing（发起态）通信Initiating状态和Scanning状态类似，只不过它的关注点不一样：它不关心广播数据，只关心ADV_DIRECT_IND和ADV_IND两类消息，并在符合条件的时候，发出CONNECT_REQ，请求建立连接。 下面是发起态的PDU定义： 广播通信模式PDU总结 如果只需要定时传输一些简单的数据（如某一个温度节点的温度信息），后续不需要建立连接，则可以使用ADV_NONCONN_IND。广播者只需要周期性的广播该类型的PDU即可，接收者按照自己的策略扫描、接收，二者不需要任何额外的数据交互。 如果除了广播数据之外，还有一些额外的数据需要传输，由于种种原因，如广播数据的长度限制、私密要求等，可以使用ADV_SCAN_IND。广播者在周期性广播的同时，会监听SCAN_REQ请求。接收者在接收到广播数据之后，可以通过SCAN_REQ PDU，请求更多的数据。 如果后续需要建立点对点的连接，则可使用ADV_IND。广播者在周期性广播的同时，会监听CONNECT_REQ请求。接收者在接收到广播数据之后，可以通过CONNECT_REQ PDU，请求建立连接。 通过ADV_IND/CONNECT_REQ的组合建立连接，花费的时间比较长。如果双方不关心广播数据，而只是想快速建立连接，恰好如果连接发起者又知道对方（广播者）的蓝牙地址（如通过扫码的方式获取），则可以通过ADV_DIRECT_IND/CONNECT_REQ的方式。 data channel对应的PDU现在唯一剩下的状态是Connection，对应的也就是data channel的基本PDU格式： LLID：Data Channel传输的PDU有两类，一类是数据，称作LL Data PDU，另一类是控制信息，称作LL Control PDU。LLID用于区分PDU的类型，具体可参考后面章节的描述。 NESN（Next Expected Sequence Number）和SN（Sequence Number）：用于数据传输过程中的应答（Acknowledgement）和流控（Flow Control），具体可参考后面章节的描述。 MD（More Data）：用于连接的关闭（或者说保持），具体可参考后面章节的描述。 RFU：预留。 Length：有效数据的长度（Payload+MIC），只有8-bits，因此LL层所能传输的最大数据是255 bytes（有MIC的话是251bytes），如果L2CAP需要传输更多的数据，需要分包之后传输（这也是L2CAP的主要功能之一）。 LL Data PDULL Data PDU有两种： Header中的LLID=01b时，Continuation fragment of an L2CAP message, or an Empty PDU。这种类型的PDU，要么是一个未传输完成L2CAP message（长度超过255，被拆包，此时不是第一个），要么是一个空包（Header中的Length为0）。 Header中的LLID=10b时，Start of an L2CAP message or a complete L2CAP message with no fragmentation。这种类型的PDU，要么是L2CAP message的第一个包，要么是不需要拆包的完整的L2CAP message，无论哪种情况，Header中的Length均不能为0。 LL Control PDUHeader中的LLID=11b时，表示这个数据包是用于控制、管理LL连接的LL control PDU。LL control PDU的payload的格式如下： 1Opcode(1 octet) + CtrlData(0 ~ 26 octets) 其中Opcode指示控制&amp;管理packet的类型，包括： LL_CONNECTION_UPDATE_REQ：连接参数的更新； LL_CHANNEL_MAP_REQ：Channel map的更新； LL_TERMINATE_IND：连接即将被关闭的通知（可以通知被关闭的原因）； LL_ENC_REQ、LL_ENC_RSP、LL_START_ENC_REQ、LL_START_ENC_RSP：加密有关的请求；等等，具体可参考“BLUETOOTH SPECIFICATION Version 4.2 [Vol 6, Part B]”。 连接的建立对BLE来说，连接建立的过程包括： 处于connectable状态设备（Advertiser），按照一定的周期广播ADV_IND或者ADV_DIRECT_IND包。 主动连接的设备（Initiator），在收到广播包之后，会回应一个ADV_CONNECT_REQ请求，该请求携带了可决定后续“通信时序”的参数，例如双方在哪一个时间点、哪一个Physical Channel收发数据，等等，后面会详细描述。 Initiator在发出ADV_CONNECT_REQ数据包之后，自动转变为Connection状态，成为Master角色（注意：这是“自动”的，不需要等待另一方的回应）。同样，Advertiser在收到ADV_CONNECT_REQ请求之后，也自动转变为Connection状态，成为Slave角色。 此后，双方按照ADV_CONNECT_REQ参数所给出的约定，定时到切换到某一个Physical Channel上，按照Master-&gt;Slave然后Slave-&gt;Master的顺序，收发数据，直至连接断开。 master在发出连接请求的时候，需要在ADV_CONNECT_REQ PDU的payload中，定义和连接有关的参数。payload的格式如下： 其中InitA和AdvA分别是Master和Slave的蓝牙地址，LL data则包含了所有的连接参数，包括： AA：LL Connection的Access Address，在不同设备组合之间，需要唯一，并遵守一些原则，具体可参考“BLUETOOTH SPECIFICATION Version 4.2 [Vol 6, Part B]”。 CRCInit：用于CRC计算的一个初始值，由LL层随机生成。 WinSize和WinOffset：全称是transmitWindowSize和transmitWindowOffset，用于决定连接双方收发数据的时间窗口下面会详细介绍。 connInterval：全称是connInterval，连接双方收发数据的周期。由于一个Master可能会和多个Slave建立连接，因此蓝牙的信道资源不能被某一个LL Connection所独占，所以一个收发周期中，可能有多个连接进行收发数据（具体的时间窗口，由transmitWindowOffset决定）。下面会详细介绍。 Latency和Timeout：全称是connSlaveLatency和connSupervisionTimeout，和连接超时、自动断开有关，下面会详细介绍。 ChM的全称是Channel map：用于标识当前使用和未使用的Physical Channel。 Hop的全称是hopIncrement：它和ChM一起决定了数据传输过程中的跳频算法，下面会详细介绍。 SCA（sleep clock accuracy）：用于定义最差的Master睡眠时钟精度，具体可参考“BLUETOOTH SPECIFICATION Version 4.2 [Vol 6, Part B]”。 Packet Sniffer抓取的ADV_CONNECT_REQ类型的PDU数据包示例： 前半段 后半段 连接建立后的通信过程BLE连接时序—Master视角： BLE连接时序—Slave视角： 从Master的视角看，当它发出CONNECT_REQ后，会在1.25 ms + transmitWindowOffset到1.25ms + transmitWindowOffset + transmitWindowSize之间，发送第一个packet（M-&gt;S）。同理，Slave在收到CONNECT_REQ之后，也会在相应的时间区间去接收packet（M-&gt;S）。 transmitWindowOffset可以控制这个LL Connection使用哪一段时间进行通信，从而保证了同一个Master和多个Slave之间的多个连接，可以互不影响的通信（时分）。transmitWindowOffset的取值范围是：0 ms到connInterval（后面会介绍connInterval）。 从Master发出CONNECT_REQ，到Slave接收到CONNECT_REQ，是有一定的时间延迟的，因此需要一定的时间窗口（transmitWindowSize），才能保证第一个packet能否正确的发送并被接收。transmitWindowSize必须是1.25ms的倍数，最小值是1.25 ms，最大值是（connInterval - 1.25 ms），但不能超过10ms。 正常情况下，所有“M-&gt;S”数据包的发送，不能超过transmitWindowSize，以便留出S-&gt;M的时间。但第一个packet例外（参考Master视角图）。 Master发出第一个packet之后，将以此为起始点（称作anchor point），以connInterval为周期，接着发送后续的packet（M-&gt;S），以及接收Slave的packet（S-&gt;M）（参考Master视角图）。 这样以connInterval为周期的发送（M-&gt;S）、接收（S-&gt;M）组合（可能有多个），称作Connection Event。因此BLE面向连接的通信的基础，就是Connection Event。 connInterval的大小，决定了数据传输的周期。对一个连接来说，每个周期只能有一次的收发，因此connInterval的选择，直接决定了数据传输的速度。BLE协议规定，connInterval必须是1.25ms的倍数，范围是7.5ms~4s。 Slave如果没有收到第一个packet（M-&gt;S），则会以1.25 ms + transmitWindowOffset为起点，等待connInterval之后，再次尝试接收，直到接收到为止。Slave接收到packet之后，则以收到该packet的时间点为起始点（anchor point），以connInterval为周期，接着接收后续的packet（M-&gt;S），以及发送packet给Master（S-&gt;M）（参考Slave视角图）。 注3：关于数据传输的速率：由上面的通信过程可知，BLE面向连接的通信速率，是由connInterval以及每个Connection Event中所传输的数据量决定的。LL Data PDU的有效负荷不能超过255（251）bytes，不过考虑到一次传输的效率、错误处理等因素，具体的Link Layer不会使用这么大的packet。相应地，为了提高传输速度，一般会在一个Connection Event中，传输多个packet。以iOS为例，它可能会在一个Connection Event中，传输6个packets，每个packet的长度是20bytes。另外，很多平台为了保证自身作为Master的性能，会限制connInterval的最小值，以iOS为例，最小值是30ms。因此，可估算得到相应的传输速率为20B * 6 / 30ms = 32kbps，是相当缓慢的。 注4：BLE的面向连接通信是使用跳频技术的，即每次Connection Event，都会使用不同Physical Channel收发数据，具体的跳频机制，可参考后面章节。 连接的控制与管理连接建立之后，Master或者Slave可以借助Link Layer Control Protocol (LLCP)，通过LL Control PDU，对连接进行管理控制，包括： Connection Update Procedure，连接参数（包括connInterval，connSlaveLatency，connSupervisionTimeout）更新的通知。只能由Master发起。 Channel Map Update Procedure，更新Channel map。只能由Master发起。 Encryption Procedure，对连接进行加密，可由master或者slave发起。 Termination Procedure，断开连接。 Connection Parameters Request Procedure，请求更新连接参数（connInterval，connSlaveLatency，connSupervisionTimeout），Slave或者Master都可以发起，和Connection Update Procedure不同是，这是一个协商的过程，不是一定能够成功。 LE Ping Procedure，类似于网络协议中ping操作。 Packet Sniffer抓取的连接参数更新PDU数据包示例： 这里不详细介绍，具体可参考“BLUETOOTH SPECIFICATION Version 4.2 [Vol 6, Part B]”。 连接超时及断开BLE连接断开的原因有两种：一种是预期内的、主动断开，此时会走上一节提到的Termination Procedure过程；第二种是一些非预期的原因导致的超时断开，如距离超出、遭受严重的干扰、突然断电等。 对于第一种，是协议内的正常流程，这里不再描述。而对于第二种，则需要timeout机制，检测这些异常情况，具体如下： Master和Slave的LL层，都会启动一个名称为TLLconnSupervision的timer，每接收到一个有效的数据包时，该timer都会重置。 连接建立的过程中，如果TLLconnSupervision超过6 * connInterval（没有接收到第一个数据包），则认为连接建立失败。 在连接成功之后，如果TLLconnSupervision超过connSupervisionTimeout，则说明link loss，则执行超时断开。connSupervisionTimeout是一个可配置的参数，范围是100ms~32s，并且不能大于(1 + connSlaveLatency) connInterval 2。 BLE协议允许slave忽略掉“connSlaveLatency”个Connection Event，在被忽略的这段时间内，Slave不需要收发数据包，也不会增加TLLconnSupervision，从而引发超时断开。connSlaveLatency是一个整数，有效范围应该在0到((connSupervisionTimeout / (connInterval*2)) - 1)之间，并且不能大于500。 注5：connSlaveLatency是一个非常有用的参数，它允许Slave在数据通信不频繁的时候，忽略掉一些Connection Event，进而可以睡得更久，更加省电。 跳频（Hopping）策略BLE的跳频策略是非常简单的，即：每一个Connection Event，更换一次Physical Channel，当然，master和slave需要按照相同的约定更换，不然就无法通信。这个约定如下： 首先，使用一个Basic的算法，利用lastUnmappedChannel和hopIncrement，计算出unmappedChannel。 lastUnmappedChannel在连接建立之初的值是0，每一次Connection Event计算出新的unmappedChannel之后，会更新lastUnmappedChannel。 hopIncrement是由Master在连接建立时随机指定的，范围是5到16（可参考3.3中的Hop）。 确定unmappedChannel的算法为：unmappedChannel = (lastUnmappedChannel + hopIncrement) mod 37，本质上就是每隔“hopIncrement”个Channel取一次，相当直白和简单。 计算出unmappedChannel之后，查找当前的Channel map，检查unmappedChannel所代表的Channel是否为used channel。如果是，恭喜，找到了。 Channel map也是由master，在连接建立时，或者后来的Channel map update的时候指定的。 如果不是，将所有的used Channel以升序的方式建一个表，表的长度是numUsedChannels，用unmappedChannel和numUsedChannels做模运算，得到一个index，从表中取出该index对应的channel即可。 应答(Acknowledgement)和流控(Flow Control)LL Data PDU的Header中，有NESN（Next Expected Sequence Number）和SN（Sequence Number）两个标记，利用它们，可以很轻松的在LL层实现应答、重传、流控等机制。 为了实现这些功能，LL层会为每个连接创建两个变量，transmitSeqNum和nextExpectedSeqNum（为了和packet的SN/NESN bit区分，我们将它们简称为sn和nesn），并在连接建立的时候，它们都被初始化为0。 sn用于标识本地设备（LL层）发送出去的packets。 nesn是对端设备（LL层）用来应答本地设备发送的packet，或者请求本地设备重发packet。 LL层在收发packet时，会遵循如下的原则： 无论是Master还是Slave，发送packet的时候，都会将当前的sn和nesn copy到packet的SN和NESN bit中。 无论是Master还是Slave，当接收到一个packet的时候，会将该packet的NESN bit和本地的sn比较：如果相同，说明该packet是对端设备发来的NAK packet（请求重发），则需要将旧的packet重新发送出去；如果不同，说明是对端设备发来的ACK packet（数据被正确接收），则需要将本地的sn加1，接着发送新的packet。 无论是Master还是Slave，当接收到一个packet的时候，会将该packet的SN bit和本地的nesn比较：如果相同，则说明是一个新的packet，接收即可，同时将本地的nesn加1；如果不同，则说明是一个旧的packet，什么都不需要处理。 当一个设备无法接收新的packet的时候（例如RX buffer已满），它可以采取不增加nesn的方式，发送NAK packet。对端设备收到该类型的packet之后，会发送旧的packet。该设备收到这样旧的packet的时候，不会做任何处理。这就是LL层的流控机制（Flow control）。 从协议栈Controler端到Host端通过上面章节对PHY、LL层的数据传输的描述，我们对整个协议栈Controler部分（包括PHY、LL和HCI层，HCI主要是对通信和配置接口的封装）有了基本的理解。那么真正和应用层如何解析数据和更新数据，就需要Host部分参与进来了。 还是从实际通信数据出发，我们一步步看Host端如何协助应用层完成数据解析和更新。 广播通信包的应用层数据解析由于图没保存，直接上一张别人抓包的图。 直接看应用层数据，也就是AdvData部分。它属于广播包，而广播和扫描响应数据包的数据格式定义是在GAP中： 广播和扫描响应数据包最长为31个字节 分为有效数据部分和无效数据部分 有效数据部分由N个AD Structure组成 每个AD Structure的格式都是Length|AD Type|AD Data。 Length的长度是1bytes AD Type的长度是1 bytes（图中是n octets，其实文档中描述的是1 octets） AD Type的格式和适用性在增补协议文档中&lt;&lt;Supplement to the Bluetooth Core Specification&gt;&gt;定义，但是具体值（也叫assigned-numbers）则由官网负责维护：https://www.bluetooth.com/specifications/assigned-numbers 在解析应用层数据时，需要根据这两份文档来确定数据的实际含义。AD Type的值在GAP文档中可以查到：https://www.bluetooth.com/specifications/assigned-numbers/generic-access-profile 下面开始分析第一个AD Structure数据的意义： Length AD Type AD Data 0B 09 4E 6F 72 64 69 63 5F 48 52 4D 11字节 Complete Local Name Nordic_HRM 第二个AD Structure数据的意义 Length AD Type AD Data 03 19 34 12 3字节 Appearance Appearance是一个16位的数值，由SIG定义，用来列举设备的外观样式，指示设备是普通手机，手环什么的。 第三个AD Structure数据的意义 Length AD Type AD Data 02 01 06 2字节 Flag flag说明了物理连接功能，比如有限发现模式，不支持经典蓝牙等。bit 0: LE 有限发现模式bit 1: LE 普通发现模式bit 2: 不支持 BR/EDRbit 3: 对 Same Device Capable(Controller) 同时支持 BLE 和 BR/EDRbit 4: 对 Same Device Capable(Host) 同时支持 BLE 和 BR/EDRbit 5..7: 预留 第四个AD Structure数据的意义 Length AD Type AD Data 07 03 0D 18 0F 18 0A 18 7字节 Complete List of 16-bit Service Class UUIDs 该设备支持的完整的16bit Service uuid列表。180D：Heart Rate service UUID(心率服务UUID) 180F：Battery service UUID(电池服务UUID)180A：Device Information service UUID(设备信息服务UUID) 16bit UUID128位的UUID相当长，设备间为了识别数据的类型需要发送长达16字节的数据。为了提高传输效率，蓝牙技术联盟(SIG)定义了一个称为“UUID基数”的128位通用唯一识别码，结合一个较短的16位数使用。二者仍然遵循通用唯一识别码的分配规则，只不过在设备间传输常用的UUID时，只发送较短的16位版本，接收方收到后补上蓝牙UUID基数即可。 蓝牙UUID基数如下：100000000 – 0000 – 1000 – 8000 – 008059B34FB 如要发送的16位UUID为0x2A01，完整的128的UUID便是：100002A01 – 0000 – 1000 – 8000 – 008059B34FB GATT16bit UUID可以理解为基于GATT协议规范的一个唯一标识码，GATT 的全名是 Generic Attribute Profile，它定义两个 BLE 设备通过叫做 Service 和 Characteristic 的东西进行通信。GATT 就是使用了 ATT（Attribute Protocol）协议，ATT 协议把 Service, Characteristic以及对应的数据保存在一个查找表中，此查找表使用16 bit ID作为每一项的索引。 GATT的结构如下： 其中Service可以理解为蓝牙设备提供的服务,服务可以有多个，蓝牙客户端可以通过Service的标识码（UUID）来获取蓝牙服务。而Characteristic则可以理解为蓝牙提供的各种服务中对应的信息，比如心率、电量等具体信息。 下面地址列出了一些通用性的GATT Service供参考：https://www.bluetooth.com/specifications/gatt/services 示例中使用到的Services： 所以从示例的广播包中，我们可以知道蓝牙设备的设备名称、设备外观、设备支持的物理连接特性、设备支持的Services等。 SDP(服务发现协议)到这里我们终于知道广播包中可以广播设备所支持的的Services，而通过这种方式我们可以知道蓝牙所支持的服务。但是通过广播这种方式很明显受到了一定的限制，如果广播中没有列出Services怎么办呢？这里就引出了蓝牙协议栈中的另一个上层核心协议SDP，也就是服务发现协议。通过这个协议，我们可以获取到一台未知的蓝牙设备上的所有Services和包含的Characteristic。然后通过不同的命令（读\\写\\通知）来操作或者获取这些Characteristic，最终完成我们的业务功能。那么Characteristic的操作我们后面再说，先看看SDP是如何完成服务发现的。 SDP的协议是基于C/S模型设计的，服务器和客户端之间的交互的格式是SDP PUD： PDU ID: 表示服务发现协议中的请求和应答指令。TransactionID：一次请求应答的唯一标识。ParameterLength：PDU中所有的parameters的长度。 按照PDU的设计，其支持的请求应答指令包括： 按照具体的请求应答指令可以组合成如下的业务场景： SDP场景：ERROR HANDLING SDP客户端如果发送了未正确格式化的请求PDU，或者在SDP服务器由于某些原因而不能生成合适的应答PDU时，SDP服务器会返回SDP_ErrorResponse应答，应答包含了错误码信息ErrorCode： PDU Type PDU ID Parameters SDP_ErrorResponse 0x01 ErrorCode SDP场景：SERVICESEARCH TRANSACTION SDP客户端生成一个带服务搜索模式参数的SDP_ServiceSearchRequest来查找服务器的服务记录，服务搜索模式参数是该PDU的首个参数。一收到该请求，SDP服务器将检查其服务记录数据库，并将返回包含服务记录句柄的SDP_ServiceSearchResponse。 SDP_ServiceSearchRequest的参数如下： PDU Type PDU ID Parameters SDP_ServiceSearchRequest 0x02 ServiceSearchPattern,MaximumServiceRecordCount,ContinuationState ServiceSearchPattern：元素内容为UUID的数据元素序列（data element sequence） MaximumServiceRecordCount：服务器可以返回的最大服务记录handles数量（16-bit） ContinuationState：当应答长度不足时用于分包传输，如果一次能传输完成则只有一个字节,数值为0（1-17 Bytes） SDP_ServiceSearchResponse的参数如下： PDU Type PDU ID Parameters SDP_ServiceSearchResponse 0x03 TotalServiceRecordCount,CurrentServiceRecordCount,ServiceRecordHandleList,ContinuationState TotalServiceRecordCount：所有满足客户端发送的服务搜索模式参数的服务记录数量（2 Bytes） CurrentServiceRecordCount：当前PDU中返回的服务记录数量（2 Bytes） ServiceRecordHandleList：返回的服务记录Handlers列表（ CurrentServiceRecordCount*4 Bytes） ContinuationState：ContinuationState：当应答长度不足时用于分包传输，如果一次能传输完成则只有一个字节,数值为0（1-17 Bytes） SDP场景：SERVICEATTRIBUTE TRANSACTION SDP客户端通过提供服务记录Handler和查找的属性范围生成一个SDP_ServiceAttributeRequest来查找服务器对应服务下的指定属性。一收到该请求，SDP服务器将检查其服务记录数据库，并将返回包含服务属性列表的SDP_ServiceAttributeResponse。 SDP_ServiceAttributeRequest的参数如下： PDU Type PDU ID Parameters SDP_ServiceAttributeRequest 0x04 ServiceRecordHandle,MaximumAttributeByteCount,AttributeIDList,ContinuationState ServiceRecordHandle：待查找属性所属的服务记录Handler（4 Bytes） MaximumAttributeByteCount：服务器可以返回的最大属性数据数量（2 Bytes） AttributeIDList：元素内容为UUID的数据元素序列（data element sequence） ContinuationState：ContinuationState：当应答长度不足时用于分包传输，如果一次能传输完成则只有一个字节,数值为0（1-17 Bytes） SDP_ServiceAttributeResponse的参数如下： PDU Type PDU ID Parameters SDP_ServiceAttributeResponse 0x05 AttributeListByteCount,AttributeList,ContinuationState AttributeListByteCount：所有查询到的属性数据数量（2 Bytes） AttributeList：返回的包含attribute ID和attribute value的数据元素序列（data element sequence） ContinuationState：ContinuationState：当应答长度不足时用于分包传输，如果一次能传输完成则只有一个字节,数值为0（1-17 Bytes） SDP场景：SERVICESEARCHATTRIBUTE TRANSACTION SDP_ServiceSearchAttributeRequest事务综合SDP_ServiceSearchRequest和SDP_ServiceAttributeRequest二者功能于一个请求中。其参数既包含服务搜索模式，又包含一张属性表，该属性表从与服务搜索模式匹配的服务记录中检索属性。SDP_ServiceSearchAttributeRequest及其应答与SDP_ServiceSearch和SDP_ServiceAttribute两者相比，显得更复杂并且可能需要更多的字节。但是,使用SDP_ServiceSearchAttributeRequest可以减少总的SDP事务量,特别是当检索多条服务记录时。 SDP_ServiceSearchAttributeRequest的参数如下： PDU Type PDU ID Parameters SDP_ServiceSearchAttributeRequest 0x06 ServiceSearchPattern,MaximumAttributeByteCount,AttributeIDList,ContinuationState ServiceSearchPattern：元素内容为UUID的数据元素序列（data element sequence） MaximumAttributeByteCount：服务器可以返回的最大属性数据数量（2 Bytes） AttributeIDList：元素内容为attribute ID或者attributeID range的数据元素序列，用于查找服务的属性（data element sequence） ContinuationState：ContinuationState：当应答长度不足时用于分包传输，如果一次能传输完成则只有一个字节,数值为0（1-17 Bytes） SDP_ServiceSearchAttributeResponse的参数如下： PDU Type PDU ID Parameters SDP_ServiceSearchAttributeResponse 0x07 AttributeListByteCount,AttributeList,ContinuationState AttributeListByteCount：所有查询到的属性数据数量（2 Bytes） AttributeList：返回的包含attribute ID和attribute value的数据元素序列（data element sequence） ContinuationState：ContinuationState：当应答长度不足时用于分包传输，如果一次能传输完成则只有一个字节,数值为0（1-17 Bytes） SDP场景通信示例下面以SERVICESEARCHATTRIBUTE TRANSACTION场景为例，来看具体的SDP通信。 SDP_ServiceSearchAttributeRequest数据帧，这里转换成二进制方便后面理解Data Element格式：100001001 00000000 00010100 00000000 00010100 00000000 01000100 00000000 00000110 00000000 00000000 00000000 00001111 00110101 00000011 00011001 00000001 00000000 00000011 11111000 00110101 00000101 00001010 00000000 00000000 11111111 11111111 00000000 最前面四个字节是HCI层的包装： Connection Handle（00001001 00000000）：0x09 Total Length（00010100 00000000）：0x0014 = 20接着四个字节是L2CAP层的包装： PDU Length（00010100 00000000）：0x0014 = 20 Channel ID（01000100 00000000）：0x0044 从协议栈的角度来说，SDP协议是在HCI和L2CAP的上层，因此在SDP协议之前会有HCI层和L2CAP层的帧结构，由于我们是从广播帧的UUID展开来说服务发现的内容，所以HCI和L2CAP这一部分内容放到后面再说，继续看SDP部分。 接着是SDP PDU： PDU ID（00000110）:0x06 = SDP_ServiceSearchAttributeRequest Transaction ID（00000000 00000000）：0x0000 Parameter Length（00000000 00001111）：0x000f = 15 接着是SDP PDU的Parameters部分，根据SDP_ServiceSearchAttributeRequest命令的描述，第一个参数是ServiceSearchPattern，其类型是data element sequence。在分析Parameters部分之前，我们先要了解data element sequence是如何解析的。data element sequence其实是data element的其中一种类型，而要区分data element的类型，先要知道data element的数据格式，为了便于理解，我们先看蓝牙核心文档中的示例，在来了解data element的具体定义： data element定义的是一种可变长度的数据格式，它通过第一个字节的high 5 bit来确定数据类型，通过low 3 bit来确定数据的大小。 协议文档中分别列出了data element通过high 5 bit确定的数据类型如下： 可以看到其中包括了Data element sequence数据类型。 协议文档也列出了data element通过low 3 bit确定的数据大小如下： 理解了data element格式后，下面继续SDP PDU的Parameters部分的解读。 ServiceSearchPattern参数： data element type（00110101的high 5 bit）：00110 = 0x06 = data element sequence data element size（00110101的low 3 bit）：101 = 0x05 = additional 8 bits，表示单独有一个byte保存data element的大小，也就是下一个byte才是data element的大小 real data element size（00000011）：0x03 表示data element的大小是3 bytes 第二个data element type（00011001的high 5 bit）：00011 = 0x03 = UUID 第二个data element size（00011001的low 3 bit）：001 = 0x01 = 2 bytes UUID（00000001 00000000）：0x0100 = L2CAP 以上完成了ServiceSearchPattern参数的解析，下面开始MaximumAttributeByteCount参数（2 bytes）： MaximumAttributeByteCount（00000011 11111000）：0x03f8 = 1016 接着AttributeIDList参数，同样也是data element sequence类型： data element type（00110101的high 5 bit）：00110 = 0x06 = data element sequence data element size（00110101的low 3 bit）：101 = 0x05 = additional 8 bits，表示单独有一个byte保存data element的大小，也就是下一个byte才是data element的大小 real data element size（00000101）：0x05 表示data element的大小是5 bytes 第二个data element type（00001010的high 5 bit）：00001 = 0x01 = Unsigned Integer 第二个data element size（00001010的low 3 bit）：010 = 0x02 = 4 bytes，这样表示的就是一个attribute ID range attribute ID range（00000000 00000000 11111111 11111111）：表示的就是从0x0000到0xffff的attribute ID 接着最后一个参数ContinuationState： ContinuationState（00000000）：0x00 所以这个SDP_ServiceSearchAttributeRequest的目的是搜索服务器上L2CAP服务上的所有Attributes。应答数据结构和请求格式类型，要特殊说明的是ContinuationState参数和TransactionID参数的运用存在两种情况。 当一次应答可以返回所有数据时，不需要Continuation State： A—&gt;B 发送SDP request，TransactionID为C B—&gt;A 发送SDP respose，TransactionID为C。假设一次resposne可以返回所有数据，则Continuation State为1个字节=0。 当一次应答不够返回所有数据时，需要Continuation State： A—&gt;B 发送SDP request，transaction ID为C B—&gt;A 发送SDP respose，transaction ID为C。假设一次resposne不够返回所有数据，这时response携带Continuation State M A—&gt;B 发送SDP request，transaction ID为D(必须与C不同）,携带Continuation State M B—&gt;A 发送SDP respose，transaction ID为D。假设这次resposne还不够返回所有数据，这时response携带Continuation State N A—&gt;B 发送SDP request，transaction ID为E,携带Continuation State N B—&gt;A 发送SDP respose，transaction ID为E。假设一次resposne返回的是最后的一部分数据，则Continuation State为1个字节=0。整个request-response的流程结束。 L2CAP在上面提到了SDP协议是在L2CAP之上的协议，所以我们回头看一下L2CAP部分。 L2CAP层向上层提供面向连接或者无连接的数据服务，通过CID来标识两个端点之间的连接。下面是LE-U支持的CIDs： 而根据信道类型的不同，建立不同类型的L2CAP连接的CID规则如下： L2CAP包格式L2CAP的数据格式是基于package，按照上面的信道和CID，L2CAP的数据包格式分为几种情况。 第一种，面向连接的基本L2CAP模式： Length：Information payload部分的长度（2 bytes） Channel ID：通道标识CID Information payload：上层数据（0-65535 bytes） 结合上一节通过SDP，假设我们已经建立连接，并且获取到了服务的Attribute。然后我们需要读取Attribute的数值： L2CAP-Length：ATT_Read_Req的数据长度为3 bytes ChanId：读写Attribute使用的是Attribute Protocol，也就是0x0004 fixed Channel。 Information payload：这里的payload使用的是上层Attribute Protocol中对应的Read Request命令。 Read Request命令： Attribute Opcode：1 byte的操作码,固定为0x0A Attribute Handle：2 bytes的Attribute handle，例子中为0x0033 Read Response命令： Attribute Opcode：1 byte的操作码,固定为0x0B Attribute Handle：ATT_MTU-1 bytes的值，例子中为01 02 03 04 05 同样可以看到写Attribute和Attribute通知也是采用相同的CID通道： 后记文章很长，基本上概况了协议栈大部分的知识点。但是内容相对比较浅，想更深入的理解协议栈还是需要多看蓝牙核心规范文档。此文章参考下面文章，都从协议栈的某个层面深入描述了其知识点。可以作为扩展阅读。 http://www.wowotech.net/bluetooth/ble_broadcast.htmlhttp://www.wowotech.net/bluetooth/ble_connection.htmlhttp://blog.sina.com.cn/s/blog_69b5d2a50101f23c.html","categories":[],"tags":[{"name":"蓝牙","slug":"蓝牙","permalink":"http://yoursite.com/tags/蓝牙/"},{"name":"ble","slug":"ble","permalink":"http://yoursite.com/tags/ble/"}]},{"title":"netty启动详细记录","slug":"netty-start","date":"2018-12-16T13:03:09.000Z","updated":"2019-01-08T05:47:56.329Z","comments":true,"path":"2018/12/16/netty-start/","link":"","permalink":"http://yoursite.com/2018/12/16/netty-start/","excerpt":"ServerBootStrap示例了解netty服务器的启动，从官方提供的4.1版本echo服务器端代码开始。","text":"ServerBootStrap示例了解netty服务器的启动，从官方提供的4.1版本echo服务器端代码开始。 Netty官方echo示例EchoServer.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public final class EchoServer &#123; static final boolean SSL = System.getProperty(\"ssl\") != null; static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\")); public static void main(String[] args) throws Exception &#123; // Configure SSL. final SslContext sslCtx; if (SSL) &#123; SelfSignedCertificate ssc = new SelfSignedCertificate(); sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build(); &#125; else &#123; sslCtx = null; &#125; // Configure the server. EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); final EchoServerHandler serverHandler = new EchoServerHandler(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline p = ch.pipeline(); if (sslCtx != null) &#123; p.addLast(sslCtx.newHandler(ch.alloc())); &#125; //p.addLast(new LoggingHandler(LogLevel.INFO)); p.addLast(serverHandler); &#125; &#125;); // Start the server. ChannelFuture f = b.bind(PORT).sync(); // Wait until the server socket is closed. f.channel().closeFuture().sync(); &#125; finally &#123; // Shut down all event loops to terminate all threads. bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 思路这篇文章关心的是netty服务器是如何启动的。因此先跳过bossGroup、workerGroup的创建细节和ServerBootstrap参数初始化细节，直接看bind接口，这里是真正服务器启动的地方。然后顺着netty启动的顺序，遇到新的知识点再展开描述与记录。 整体启动脉络netty启动涉及到多线程，为了便于以后快速回顾，先将整体启动的大致过程记录下来。绿色部分是给子线程分配的关键初始化任务。 netty启动相关类介绍一开始虽然不会详细介绍bossGroup、workerGroup和ServerBootstrap的细节，但是还是先要对启动相关类有个基本认识。 ServerBootstrap：为了简化服务器启动过程，所有启动相关的接口和参数都封装到这里，相当于一个门面(Facade)模式。 Channel：是netty的核心接口类，除了提供IO操作的接口之外，还提供对于核心组件的访问接口。如果把netty比作一台机器可以说是Channel将机器上所有的基本零件连接在了一起。 ChannelFuture：通过它可以读取Channel中的异步操作的状态和结果，简单描述可以分为uncompleted和completed两种情况，而completed又包括Completed successfully、Completed with failure 、Completed by cancellation三种状态。另外它也可以添加ChannelFutureListener监听器，来监听异步I/O操作结果并执行后续操作。 ChannelPromise：可以设置异步操作的状态和结果的一种特殊ChannelFuture。在启动过程中会用到它的默认实现DefaultChannelPromise。 DefaultChannelPromise：在设置异步IO操作成功或者失败之后会通知相应的listeners的默认ChannelPromise。 服务器的启动入口直接看bind操作： 12345//ServerBootstrap.java // Start the server. ChannelFuture f = b.bind(PORT).sync(); bind方法调用基类AbstractBootstrap的bind方法： 12345678910//AbstractBootstrap.java public ChannelFuture bind(SocketAddress localAddress) &#123; //验证服务启动的必要参数 validate(); if (localAddress == null) &#123; throw new NullPointerException(\"localAddress\"); &#125; return doBind(localAddress); &#125; bind方法继续调用doBind方法： 1234567891011121314151617181920212223242526272829303132333435363738//AbstractBootstrap.java private ChannelFuture doBind(final SocketAddress localAddress) &#123; final ChannelFuture regFuture = initAndRegister(); final Channel channel = regFuture.channel(); if (regFuture.cause() != null) &#123; return regFuture; &#125; if (regFuture.isDone()) &#123; // At this point we know that the registration was complete and successful. ChannelPromise promise = channel.newPromise(); doBind0(regFuture, channel, localAddress, promise); return promise; &#125; else &#123; // Registration future is almost always fulfilled already, but just in case it's not. final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel); regFuture.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) throws Exception &#123; Throwable cause = future.cause(); if (cause != null) &#123; // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an // IllegalStateException once we try to access the EventLoop of the Channel. promise.setFailure(cause); &#125; else &#123; // Registration was successful, so set the correct executor to use. // See https://github.com/netty/netty/issues/2586 promise.registered(); doBind0(regFuture, channel, localAddress, promise); &#125; &#125; &#125;); return promise; &#125; &#125; doBind方法最终调用doBind0方法。这里regFuture其实是记录注册异步操作结果的ChannelPromise实例，通过regFuture.isDone()判断注册异步操作是否完成，存在两种情况： 注册操作没有完成：先给regFuture增加一个监听器，如果注册成功没有错，就会在设置regFuture结果的地方调用doBind0方法 注册操作已经完成，则立即调用doBind0方法 两者的区别在于调用此方法的线程不同。注册完成就直接在主线程调用，没有完成其实是在workGroup子线程中通过触发linster回调doBind0方法。但是殊途同归的是最终真正执行bind操作的地方都是在workGroup子线程中。 initAndRegister方法调用doBind0方法之前，regFuture和channel参数都是通过initAndRegister方法创建的。 123456789101112//AbstractBootstrap.java final ChannelFuture initAndRegister() &#123; Channel channel = null; //... channel = channelFactory.newChannel(); init(channel); //... ChannelFuture regFuture = config().group().register(channel); //... return regFuture; &#125; initAndRegister方法内部主要完成了三件事 创建channel 初始化channel 返回注册的异步结果regFuture 我们先看如何创建channel。 确定创建的channel类型channel是通过channelFactory.newChannel()方法完成创建的，那channelFactory是如何创建的，对象的类型是什么？其实通过代码可以确定channelFactory对象实际的类型是ReflectiveChannelFactory。它通过ServerBootstrap的channel接口完成创建和赋值： 1.channel(NioSocketChannel.class) 123456789101112131415161718192021//AbstractBootstrap.java public B channel(Class&lt;? extends C&gt; channelClass) &#123; if (channelClass == null) &#123; throw new NullPointerException(\"channelClass\"); &#125; return channelFactory(new ReflectiveChannelFactory&lt;C&gt;(channelClass)); &#125; public B channelFactory(ChannelFactory&lt;? extends C&gt; channelFactory) &#123; if (channelFactory == null) &#123; throw new NullPointerException(\"channelFactory\"); &#125; if (this.channelFactory != null) &#123; throw new IllegalStateException(\"channelFactory set already\"); &#125; this.channelFactory = channelFactory; return self(); &#125; ReflectiveChannelFactory的newChannel方法通过反射的方式创建对象，创建的对象类型为通过构造函数传入的类类型，也就是NioSocketChannel.class类型。因此只要通过ServerBootstrap的channel接口传入具体的类，就决定Netty服务器创建的Channel类型。 12345678910111213141516171819202122public class ReflectiveChannelFactory&lt;T extends Channel&gt; implements ChannelFactory&lt;T&gt; &#123; private final Class&lt;? extends T&gt; clazz; public ReflectiveChannelFactory(Class&lt;? extends T&gt; clazz) &#123; if (clazz == null) &#123; throw new NullPointerException(\"clazz\"); &#125; this.clazz = clazz; &#125; @Override public T newChannel() &#123; try &#123; return clazz.getConstructor().newInstance(); &#125; catch (Throwable t) &#123; throw new ChannelException(\"Unable to create Channel from class \" + clazz, t); &#125; &#125; ...&#125; NioServerSocketChannel扩展理解Channel作为netty的核心组件之一，为了加深理解，我们先做简单的介绍： NioSocketChannel, 代表异步的客户端 TCP Socket 连接 NioServerSocketChannel, 异步的服务器端 TCP Socket 连接 NioDatagramChannel, 异步的 UDP 连接 NioSctpChannel, 异步的客户端 Sctp 连接 NioSctpServerChannel, 异步的 Sctp 服务器端连接 OioSocketChannel, 同步的客户端 TCP Socket 连接 OioServerSocketChannel, 同步的服务器端 TCP Socket 连接 OioDatagramChannel, 同步的 UDP 连接 OioSctpChannel, 同步的 Sctp 服务器端连接 OioSctpServerChannel, 同步的客户端 TCP Socket 连接 Channel层级结构： 12345678910111213141516171819202122AbstractChannel||--AbstractNioChannel| |--AbstractNioByteChannel| |--NioSocketChannel||--AbstractNioMessageChannel| |--NioServerSocketChannel| |--NioDatagramChannel| |--NioSctpServerChannel| |--NioSctpChannel||--AbstractOioChannel| |--AbstractOioByteChannel| |--OioByteStreamChannel| |--OioSocketChannel||--AbstractOioMessageChannel| |--OioServerSocketChannel| |--OioDatagramChannel| |--OioSctpServerChannel| |--OioSctpChannel 以上channel可以理解为netty对传输层的具体实现，而AbstractChannel是netty对传输层的抽象，但是也通过采用Facade模式聚合了很多内部组件，包括了Unsafe、ChannelPipeline、EventLoop、ChannelPromise等，对外提供了统一接口。 而在AbstractChannel层次之上又分为AbstractOioChannel（阻塞）和AbstractNioChannel（非阻塞）。他们的最大的区别在于AbstractNioChannel类内部存在一个SelectableChannel类型的成员变量。SelectableChannel是一个可以通过Selector来进行多路复用的通道。 AbstractChannel核心类介绍在继续NioServerSocketChannel的创建之前，我们再看看AbstractChannel核心组件： ChannelId：每个Channel的唯一标识，这个唯一标识通过DefaultChannelId产生。 Unsafe：它是Channel的辅助接口，不应该被用户代码直接使用，而实际的IO操作应该都由Unsafe接口负责完成。 DefaultChannelPipeline：维护一个AbstractChannelHandlerContext的链表，通过这个链表中的handler处理器来处理Channel上的数据。AbstractChannelHandlerContext放到pipeline部分再详细介绍。 EventLoop：主要负责执行Channel生命周期内的事件轮询和各种任务。 AbstractNioChannel核心类介绍 SelectableChannel：是java nio中的抽象类，本身可以通过Selector来支持多路复用通道，且提供两种模式Blocking mode和Non-blocking mode，SelectableChannel的Non-blocking mode是实现Netty的异步IO事件机制的基础。而要使用Non-blocking mode，需要先设置为Non-blocking mode模式，再通过register(Selector,int,Object)接口绑定Selector并拿到返回的SelectionKey对象。 SelectionKey：SelectableChannel与Selector注册的标识。 NioServerSocketChannel核心类介绍 ChannelConfig：操作Channel的配置属性集的接口，包括ChannelOption配置和传输相关的属性。 ChannelOption：提供一种类型安全的方式来表现配置信息。比如配置超时时间CONNECT_TIMEOUT_MILLIS。 1public static final ChannelOption&lt;Integer&gt; CONNECT_TIMEOUT_MILLIS = valueOf(&quot;CONNECT_TIMEOUT_MILLIS&quot;); DefaultChannelConfig：对于ChannelConfig的默认实现，内部实现了对各种ChannelOption类型的统一访问，实现了对ByteBufAllocator的访问，以及Channel中的各种默认配置的访问，如读取数据长度、连接超时时间等。 DefaultServerSocketChannelConfig：DefaultChannelConfig的子类，实现了通过ServerSocketChannelConfig提供的扩展接口，内部存储了ServerSocket的实例。 NioServerSocketChannelConfig：DefaultServerSocketChannelConfig的子类，实现了autoReadCleared接口。 NioServerSocketChannel的类图 创建NioServerSocketChannel 通过工厂模式创建的NioServerSocketChannel调用的是默认的构造函数，而默认构造函数内部调用了带参数的构造函数： 1234567891011//NioServerSocketChannel.java public NioServerSocketChannel() &#123; this(newSocket(DEFAULT_SELECTOR_PROVIDER)); &#125; public NioServerSocketChannel(ServerSocketChannel channel) &#123; super(null, channel, SelectionKey.OP_ACCEPT); config = new NioServerSocketChannelConfig(this, javaChannel().socket()); &#125; DEFAULT_SELECTOR_PROVIDER是通过SelectorProvider.provider()创建的类静态变量： 1private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider(); 12345678//SelectorProvider.java public static SelectorProvider provider() &#123; //... provider = sun.nio.ch.DefaultSelectorProvider.create(); return provider; &#125; 123456//DefaultSelectorProvider.java public static SelectorProvider create() &#123; return new WindowsSelectorProvider(); &#125; channel的创建和平台相关，都是通过对应平台的provider来创建平添相关的channel，以windows平台为例：DEFAULT_SELECTOR_PROVIDER对象的实际类型是WindowsSelectorProvider。因此newSocket方法调用的provider.openServerSocketChannel方法，在WindowsSelectorProvider父类SelectorProviderImpl中被实现： 1234567891011//NioServerSocketChannel.java private static ServerSocketChannel newSocket(SelectorProvider provider) &#123; try &#123; return provider.openServerSocketChannel(); &#125; catch (IOException e) &#123; throw new ChannelException( \"Failed to open a server socket.\", e); &#125; &#125; 123456//WindowsSelectorImpl.java public ServerSocketChannel openServerSocketChannel() throws IOException &#123; return new ServerSocketChannelImpl(this); &#125; ServerSocketChannelImpl类内部通过Net组件来实现对本地socket的操作。 所以回到this()构造函数的调用，实际传入的实参类型为ServerSocketChannelImpl。 1234567//NioServerSocketChannel.java public NioServerSocketChannel(ServerSocketChannel channel) &#123; super(null, channel, SelectionKey.OP_ACCEPT); config = new NioServerSocketChannelConfig(this, javaChannel().socket()); &#125; 到这里直接参考NioServerSocketChannel实例化流程图可以基本理解NioServerSocketChannel实例化过程。 过程中有几点还是记录下来： ServerSocketChannelImpl保存到this.ch中，转换成了SelectableChannel类型。 初始化过程中通过ch.configureBlocking(false);将AbstractSelectableChannel的blocking字段设为false，也就是将ch设置为非阻塞模式。后面只要调用register接口就可以完成channel和selector的注册。 创建的NioServerSocketChannelConfig对象的成员变量channel和javaSocket对应的实例对象为NioServerSocketChannel和经过ServerSocketAdaptor类型转换后的ServerSocket，实际上还是ServerSocketChannelImpl。 unsafe实际对应的是NioMessageUnsafe。NioMessageUnsafe重写了read接口，read方法通过doReadMessages()处理NioServerSocketChannel的accept操作。如果此时没有客户端连接，则退出for循环进行后续的处理，如果有客户端连接，则将客户端NioSocketChannel保存到readBuf中（默认不超过16个），如果超过16个，则也退出for循环进行后续的处理。最后将readBuf传到pipeline去解析。 pipeline的创建其中pipeline是很重要的组件，所以再详细看一下pipeline的创建。 先介绍pipeline的核心类： AttributeKey：用于从AttributeMap中访问Attribute的键 Attribute：存储与操作泛型数据的接口 AttributeMap：提供通过AttributeKey来获取Attribute类型的value的接口。 DefaultAttributeMap：AttributeMap的的默认实现，用来存取AttributeMap的数据。 ChannelInboundInvoker：定义了ChannelHandlerContext传递inbound事件的方法。 ChannelOutboundInvoker：定义了ChannelHandlerContext传递outbound事件的接口。 ChannelHandlerContext：提供了访问各种资源如Channel、ChannelHandler、EventExecutor、ChannelPipeline、ByteBufAllocator、Attribute的方法，并且实现了ChannelInboundInvoker和ChannelOutboundInvoker来规范inbound和outbound事件的处理接口。 AbstractChannelHandlerContext：它继承了DefaultAttributeMap，因此它有存取AttributeMap数据的能力，同时它也实现了ChannelHandlerContext接口，因此它也拥有访问pipeline的各种资源的能力。 这里还要补充一下，Channel和AbstractChannelHandlerContext都实现了AttributeMap接口，因此每一个Channel和ChannelHandlerContext实例都可以像Map一样来存取key和value，唯一的区别是ChannelHandlerContext的AttributeMap仅用于当前具体的ChannelHandler子类实例，而Channel的AttributeMap可以被用于所有的ChannelHandlerContext链表中的ChannelHandler子类实例。 123456//AbstractChannel.java protected DefaultChannelPipeline newChannelPipeline() &#123; return new DefaultChannelPipeline(this); &#125; 1234567891011121314//DefaultChannelPipeline.java protected DefaultChannelPipeline(Channel channel) &#123; this.channel = ObjectUtil.checkNotNull(channel, \"channel\"); succeededFuture = new SucceededChannelFuture(channel, null); voidPromise = new VoidChannelPromise(channel, true); tail = new TailContext(this); head = new HeadContext(this); head.next = tail; tail.prev = head; &#125; 创建过程比较简单： DefaultChannelPipeline绑定的channel就是NioServerSocketChannel，并创建了succeededFuture、voidPromise用于异步操作支持。 创建TailContext和HeadContext来填充AbstractChannelHandlerContext链表结构，channel的handler都会放到这个链表。 NioServerSocketChannel的初始化完成了NioServerSocketChannel的创建之后，接着执行NioServerSocketChannel的初始化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//ServerBootstrap.javavoid init(Channel channel) throws Exception &#123; final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0(); synchronized (options) &#123; setChannelOptions(channel, options, logger); &#125; final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0(); synchronized (attrs) &#123; for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123; @SuppressWarnings(\"unchecked\") AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey(); channel.attr(key).set(e.getValue()); &#125; &#125; ChannelPipeline p = channel.pipeline(); final EventLoopGroup currentChildGroup = childGroup; final ChannelHandler currentChildHandler = childHandler; final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions; final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs; synchronized (childOptions) &#123; currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0)); &#125; synchronized (childAttrs) &#123; currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0)); &#125; p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123; @Override public void initChannel(final Channel ch) throws Exception &#123; final ChannelPipeline pipeline = ch.pipeline(); ChannelHandler handler = config.handler(); if (handler != null) &#123; pipeline.addLast(handler); &#125; ch.eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; pipeline.addLast(new ServerBootstrapAcceptor( ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)); &#125; &#125;); &#125; &#125;);&#125; 初始化完成了几个工作 如果用户代码有调用AbstractBootstrap.option接口保存ChannelOption，那么这里将ChannelOption用来配置NioServerSocketChannel的config对象。 如果用户代码有调用AbstractBootstrap.attr接口保存AttributeKey和Attribute，那么这里将保存的AttributeKey和Attribute键值对复制到channel。 ChannelInitializer&lt;Channel&gt;()对象的基类是ChannelHandler，最终会封装到一个AbstractChannelHandlerContext对象内部，再加入到pipeline双向链表中。 调用addLast接口时，由于NioServerSocketChannel还没有注册完成，所以会额外创建一个封装了ChannelInitializer&lt;Channel&gt;()的AbstractChannelHandlerContext对象，并加入到一个新的PendingHandlerAddedTask对象中，再将此对象加入到pipeline的pendingHandlerCallbackHead单项链表上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//DefaultChannelPipeline.java public final ChannelPipeline addLast(ChannelHandler handler) &#123; return addLast(null, handler); &#125; public final ChannelPipeline addLast(String name, ChannelHandler handler) &#123; return addLast(null, name, handler); &#125; public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) &#123; final AbstractChannelHandlerContext newCtx; synchronized (this) &#123; checkMultiplicity(handler); newCtx = newContext(group, filterName(name, handler), handler); addLast0(newCtx); // registered 为 false 标识channel还没有注册到eventloop中。 // 这种情况下处理会在pipeline中加入一个context外，还添加了一个task，当channel注册完成的时候，这个task会执行 ChannelHandler.handlerAdded(...)。 if (!registered) &#123; newCtx.setAddPending(); callHandlerCallbackLater(newCtx, true); return this; &#125; EventExecutor executor = newCtx.executor(); if (!executor.inEventLoop()) &#123; newCtx.setAddPending(); executor.execute(new Runnable() &#123; @Override public void run() &#123; callHandlerAdded0(newCtx); &#125; &#125;); return this; &#125; &#125; callHandlerAdded0(newCtx); return this; &#125; private void callHandlerCallbackLater(AbstractChannelHandlerContext ctx, boolean added) &#123; assert !registered; PendingHandlerCallback task = added ? new PendingHandlerAddedTask(ctx) : new PendingHandlerRemovedTask(ctx); PendingHandlerCallback pending = pendingHandlerCallbackHead; if (pending == null) &#123; pendingHandlerCallbackHead = task; &#125; else &#123; // Find the tail of the linked-list. while (pending.next != null) &#123; pending = pending.next; &#125; pending.next = task; &#125; &#125; 提前说明这个PendingHandlerAddedTask的作用：存入pendingHandlerCallbackHead链表的PendingHandlerAddedTask等到channel注册完成之后会取出并执行。执行时调用PendingHandlerAddedTask的execute方法，此方法先调用callHandlerAdded0，callHandlerAdded0再调用ctx.handler().handlerAdded(ctx);。 123456789101112131415161718192021222324252627282930313233343536373839//DefaultChannelPipeline.java private final class PendingHandlerAddedTask extends PendingHandlerCallback &#123; @Override public void run() &#123; callHandlerAdded0(ctx); &#125; @Override void execute() &#123; EventExecutor executor = ctx.executor(); if (executor.inEventLoop()) &#123; callHandlerAdded0(ctx); &#125; else &#123; try &#123; executor.execute(this); &#125; catch (RejectedExecutionException e) &#123; if (logger.isWarnEnabled()) &#123; logger.warn( \"Can't invoke handlerAdded() as the EventExecutor &#123;&#125; rejected it, removing handler &#123;&#125;.\", executor, ctx.name(), e); &#125; remove0(ctx); ctx.setRemoved(); &#125; &#125; &#125; &#125; private void callHandlerAdded0(final AbstractChannelHandlerContext ctx) &#123; try &#123; ctx.setAddComplete(); ctx.handler().handlerAdded(ctx); &#125; catch (Throwable t) &#123; //... &#125; &#125; 其中ctx.handler()是ChannelInitializer，而ctx.handler().handlerAdded(ctx);实际上调用的是initChannel接口。而在channel注册时创建的ChannelInitializer&lt;Channel&gt;()刚好重写了此接口。 12345678//ChannelInitializer.java public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123; if (ctx.channel().isRegistered()) &#123; initChannel(ctx); &#125; &#125; 所以等到channel注册完成之后，会调用ChannelInitializer&lt;Channel&gt;()重写的initChannel方法执行channel的额外初始化。这部分初始化代码等到注册完成时再说。 NioServerSocketChannel注册入口完成了NioServerSocketChannel的初始化之后，返回到initAndRegister方法继续往下看注册流程：1ChannelFuture regFuture = config().group().register(channel); 这里的config()是ServerBootstrap的内部成员变量：1private final ServerBootstrapConfig config = new ServerBootstrapConfig(this); config().group()对应的是AbstractBootstrap的group成员变量： 123456//AbstractBootstrapConfig.java public final EventLoopGroup group() &#123; return bootstrap.group(); &#125; 123456//AbstractBootstrap.java public final EventLoopGroup group() &#123; return group; &#125; 而group成员变量是通过ServerBootstrap的group方法初始化的： 1234567891011121314//ServerBootstrap.java public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) &#123; super.group(parentGroup); if (childGroup == null) &#123; throw new NullPointerException(\"childGroup\"); &#125; if (this.childGroup != null) &#123; throw new IllegalStateException(\"childGroup set already\"); &#125; this.childGroup = childGroup; return this; &#125; 在示例代码中对应的是bossGroup，而其childGroup成员变量保存的是workerGroup：1b.group(bossGroup, workerGroup) 它们是通过NioEventLoopGroup创建的： 1234EventLoopGroup bossGroup = new NioEventLoopGroup(1);EventLoopGroup workerGroup = new NioEventLoopGroup(); 到这里我们又进入了另一大Netty的核心：EventLoop和EventLoopGroup，待会会详细介绍。 最终config().group().register(channel)函数实际上调用的是NioEventLoopGroup的register方法，但实现是在父类MultithreadEventLoopGroup中： 12345678910//MultithreadEventLoopGroup.java public ChannelFuture register(Channel channel) &#123; return next().register(channel); &#125; public EventLoop next() &#123; return (EventLoop) super.next(); &#125; 而MultithreadEventLoopGroup实际上也不是直接注册，而是通过父类的next接口获取到一个EventExecutor并转换为EventLoop类型: 123456//MultithreadEventExecutorGroup.java public EventExecutor next() &#123; return chooser.next(); &#125; 看到这里出现了chooser、EventExecutor以及EventLoop这些新的组件，以及一开始创建的两个NioEventLoopGroup对象bossGroup和workerGroup，而为了便于理解这部分内容，在接着看注册流程之前，必须先对netty的线程模型有个基本的认识。如果对NioEventLoopGroup和NioEventLoop有了基本的认识，则可以跳过直接看继续Channel的注册流程的章节。 Reactor模型的理解对NioEventLoopGroup的理解参考了此篇文章：https://segmentfault.com/a/1190000007403873 要理解NioEventLoopGroup，首先还是要知道Netty线程模型是Reactor设计模式的一个实现。Reactor设计模式中有两个重要角色： Reactor的职责是检测网络IO事件并分发给合适的handler处理。 Handlers的职责是执行非阻塞的行为。 而Reactor设计模式根据线程的数量和作用又分为三种Reactor线程模型 单线程模型 多线程模型 主从多线程模型 单线程模型所有工作都在一个线程执行，会由于其中某个handler的阻塞而导致整个服务的阻塞。因此单线程Reactor 模型用的比较少。 多线程模型与单线程模型的区别在于由单独的线程处理accept事件，其它IO操作事件和处理工作放到一组特定的NIO线程来监听处理。Reactor多线程模型如下： 多线程模型改善了handler阻塞对系统的影响，但是对于同时处理大量连接或者在连接时需要进行一些权限检测等工作时，那么单线程处理这些工作仍然负荷较大，可能会影响其它客户端的连接，那么主从多线程则将异步连接事件后续的处理工作也划分到从Reactor线程池来处理，主Reactor线程只负责分配任务。主从Reactor多线程模型如下： 那么回头看我们的示例，netty采用的其实就是Reactor多线程模型，bossGroup单线程处理accept事件，workerGroup线程池处理其它工作： 1234567EventLoopGroup bossGroup = new NioEventLoopGroup(1);EventLoopGroup workerGroup = new NioEventLoopGroup();//...ServerBootstrap b = new ServerBootstrap();b.group(bossGroup, workerGroup) 有了netty模型的基本概念之后，再来细看NioEventLoopGroup和NioEventLoop： NioEventLoopGroup类层次结构 NioEventLoopGroup实例化过程NioEventLoopGroup实例化的序列图中，省略了NioEventLoop的实例化过程，NioEventLoop的实例化后面再单独描述。 实例化流程比较简单，只说图中没有明确提到的部分： NioEventLoopGroup内部维护了一份类型为EventExecutor的children数组，children数组实际通过newChild()方法创建的实际对象类型是NioEventLoop。 executor存储的是一个ThreadPerTaskExecutor类型的实例，，它实现了execute(Runnable command)接口，只要调用此接口，就会将传入的command作为线程的执行体，通过DefaultThreadFactory.newThread(Runnable r)接口创建线程，并启动线程。而最终此executor会作为参数传递到NioEventLoop中，也就是传递给children数组中的每一个元素。 123456//ThreadPerTaskExecutor.java public void execute(Runnable command) &#123; threadFactory.newThread(command).start(); &#125; 123456789101112131415161718//DefaultThreadFactory.java public Thread newThread(Runnable r) &#123; Thread t = newThread(FastThreadLocalRunnable.wrap(r), prefix + nextId.incrementAndGet()); try &#123; if (t.isDaemon() != daemon) &#123; t.setDaemon(daemon); &#125; if (t.getPriority() != priority) &#123; t.setPriority(priority); &#125; &#125; catch (Exception ignored) &#123; // Doesn't matter even if failed to set. &#125; return t; &#125; 如果调用构造函数没有设置nThreads数量，则nThreads的数量为DEFAULT_EVENT_LOOP_THREADS，也就是处理器核心数*2 如果nThreads数量是2的次方，则实际通过chooserFactory.newChooser(children)创建的chooser为PowerOfTwoEventExecutorChooser，否则为GenericEventExecutorChooser，这两者的区别在于实现了不同的next方法策略来选择children中的某一个EventExecutor。 NioEventLoop类的层次结构NioEventLoop类的层次结构比较多，重点关注SingleThreadEventExecutor中的thread和executor，它们为NioEventLoop提供了执行线程任务的基础。 NioEventLoop实例化过程 根据上面的图，再补充解释整个NioEventLoopGroup和NioEventLoop的实例化过程： NioEventLoopGroup实例化时，根据传入的需要创建的线程数量，创建了对应数量的NioEventLoop实例，并且最终的executor实例是保存在每一个NioEventLoop实例中。 同样的selectorProvider最终也是传递给NioEventLoop用于创建selector实例，不同的在于selectorProvider只有一份实例。 图中忽略了selector实例的创建，简单描述是selectorProvider会根据操作系统来返回不同平台的selectorProvider，而不同平台的selectorProvider通过实现openSelector()来实例化平台相关的selector。 整个过程SingleThreadEventExecutor的thread属性还没有被赋值，这个属性后面会用到。 继续Channel的注册流程通过前面五节的介绍，注册函数链式调用group().next()实际通过chooser返回EventExecutor对象也就很容易理解了，其真实意图是在NioEventLoopGroup的chlidren数组中选择一个EventExecutor。也可以认为是返回一个NioEventLoop，它们都在一个继承链上。而NioEventLoop的父类SingleThreadEventLoop实现了register(channel)接口，所以group().next().register(channel)实际最后调用的是SingleThreadEventLoop.register(channel)。调用完成实际的返回值是DefaultChannelPromise，用于保存注册的状态。 1234567891011121314//SingleThreadEventLoop.java @Override public ChannelFuture register(Channel channel) &#123; return register(new DefaultChannelPromise(channel, this)); &#125; @Override public ChannelFuture register(final ChannelPromise promise) &#123; ObjectUtil.checkNotNull(promise, \"promise\"); promise.channel().unsafe().register(this, promise); return promise; &#125; 而SingleThreadEventLoop.register(channel)内部的promise.channel().unsafe().register(this, promise)调用层次很深，我们直接跳过。最终调用到AbstractUnsafe的register方法： 12345678910111213141516171819202122232425262728//AbstractUnsafe.java public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123; //... AbstractChannel.this.eventLoop = eventLoop; if (eventLoop.inEventLoop()) &#123; register0(promise); &#125; else &#123; try &#123; eventLoop.execute(new Runnable() &#123; @Override public void run() &#123; register0(promise); &#125; &#125;); &#125; catch (Throwable t) &#123; logger.warn( \"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;\", AbstractChannel.this, t); closeForcibly(); closeFuture.setClosed(); safeSetFailure(promise, t); &#125; &#125; &#125; AbstractUnsafe的register方法首先将eventLoop绑定到NioServerSocketChannel上，然后通过eventLoop.inEventLoop方法判断当前线程是否已经处于该事件循环器线程中： 123456//AbstractUnsafe.java public boolean inEventLoop() &#123; return inEventLoop(Thread.currentThread()); &#125; 123456//SingleThreadEventExecutor.java public boolean inEventLoop(Thread thread) &#123; return thread == this.thread; &#125; 从代码看，最终判断的依据是SingleThreadEventExecutor的thread属性，也就是我们提到的在NioEventLoop初始化完成后仍然为空的thread。所以此时判断肯定不在同一个线程中。所以最终会执行eventLoop.execute(new Runnable())的分支。 启动第一个新事件监听器线程到这里终于进入了一个新的阶段，因为第一个事件监听器线程被创建了。通过NioEventLoop的类的层次结构知道NioEventLoop的是一个Executor,而在SingleThreadEventExecutor中实现了execute接口。eventLoop.execute(new Runnable())调用的实际就是SingleThreadEventExecutor.execute(Runnable task)方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//SingleThreadEventExecutor.java public void execute(Runnable task) &#123; if (task == null) &#123; throw new NullPointerException(\"task\"); &#125; boolean inEventLoop = inEventLoop(); addTask(task); if (!inEventLoop) &#123; startThread(); if (isShutdown() &amp;&amp; removeTask(task)) &#123; reject(); &#125; &#125; if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123; wakeup(inEventLoop); &#125; &#125; protected void addTask(Runnable task) &#123; if (task == null) &#123; throw new NullPointerException(\"task\"); &#125; if (!offerTask(task)) &#123; reject(task); &#125; &#125; final boolean offerTask(Runnable task) &#123; if (isShutdown()) &#123; reject(); &#125; return taskQueue.offer(task); &#125; private void startThread() &#123; if (state == ST_NOT_STARTED) &#123; if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) &#123; try &#123; doStartThread(); &#125; catch (Throwable cause) &#123; STATE_UPDATER.set(this, ST_NOT_STARTED); PlatformDependent.throwException(cause); &#125; &#125; &#125; &#125; private void doStartThread() &#123; assert thread == null; executor.execute(new Runnable() &#123; @Override public void run() &#123; thread = Thread.currentThread(); //... SingleThreadEventExecutor.this.run(); //... &#125; &#125;); &#125; SingleThreadEventExecutor.execute(Runnable task)首先将task存入taskQueue，也就是将register0操作放入任务队列。接着因为目前还是在主线程调用的execute方法，所以会执行startThread分支。startThread方法又调用了doStartThread分支。 事件监听与处理线程继续看doStartThread方法。在doStartThread内部通过executor创建线程并启动线程。前面在NioEventLoopGroup实例化过程中描述了executor如何创建和启动线程。这里再介绍一次：executor存储的是一个ThreadPerTaskExecutor类型的实例。它实现了execute(Runnable command)接口，只要调用此接口，就会将传入的command作为线程的执行体。其内部通过DefaultThreadFactory.newThread(Runnable r)接口创建线程，并启动线程。而executor是会在创建NioEventLoopGroup的children数组元素时，作为参数传递给children数组中的每一个NioEventLoop保存。 因此这里再调用executor.execute(new Runnable())方法时，就会启动一个新的线程，并执行run方法。而run方法内部终于将NioEventLoop的thread字段更新为当前创建的子线程。并最终调用了SingleThreadEventExecutor.this.run()方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//SingleThreadEventExecutor.java private void doStartThread() &#123; assert thread == null; executor.execute(new Runnable() &#123; @Override public void run() &#123; thread = Thread.currentThread(); if (interrupted) &#123; thread.interrupt(); &#125; boolean success = false; updateLastExecutionTime(); try &#123; SingleThreadEventExecutor.this.run(); success = true; &#125; catch (Throwable t) &#123; logger.warn(\"Unexpected exception from an event executor: \", t); &#125; finally &#123; for (;;) &#123; int oldState = state; if (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet( SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) &#123; break; &#125; &#125; // Check if confirmShutdown() was called at the end of the loop. if (success &amp;&amp; gracefulShutdownStartTime == 0) &#123; if (logger.isErrorEnabled()) &#123; logger.error(\"Buggy \" + EventExecutor.class.getSimpleName() + \" implementation; \" + SingleThreadEventExecutor.class.getSimpleName() + \".confirmShutdown() must \" + \"be called before run() implementation terminates.\"); &#125; &#125; try &#123; // Run all remaining tasks and shutdown hooks. for (;;) &#123; if (confirmShutdown()) &#123; break; &#125; &#125; &#125; finally &#123; try &#123; cleanup(); &#125; finally &#123; STATE_UPDATER.set(SingleThreadEventExecutor.this, ST_TERMINATED); threadLock.release(); if (!taskQueue.isEmpty()) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"An event executor terminated with \" + \"non-empty task queue (\" + taskQueue.size() + ')'); &#125; &#125; terminationFuture.setSuccess(null); &#125; &#125; &#125; &#125; &#125;); &#125; 而SingleThreadEventExecutor本身并没有实现run方法，而是在子类NioEventLoop实现了run方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//NioEventLoop.java protected void run() &#123; for (;;) &#123; try &#123; switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123; case SelectStrategy.CONTINUE: continue; case SelectStrategy.SELECT: select(wakenUp.getAndSet(false)); if (wakenUp.get()) &#123; selector.wakeup(); &#125; // fall through default: &#125; cancelledKeys = 0; needsToSelectAgain = false; final int ioRatio = this.ioRatio; if (ioRatio == 100) &#123; try &#123; processSelectedKeys(); &#125; finally &#123; // Ensure we always run tasks. runAllTasks(); &#125; &#125; else &#123; final long ioStartTime = System.nanoTime(); try &#123; processSelectedKeys(); &#125; finally &#123; // Ensure we always run tasks. final long ioTime = System.nanoTime() - ioStartTime; runAllTasks(ioTime * (100 - ioRatio) / ioRatio); &#125; &#125; &#125; catch (Throwable t) &#123; handleLoopException(t); &#125; // Always handle shutdown even if the loop processing threw an exception. try &#123; if (isShuttingDown()) &#123; closeAll(); if (confirmShutdown()) &#123; return; &#125; &#125; &#125; catch (Throwable t) &#123; handleLoopException(t); &#125; &#125; &#125; 先简单描述当前for循环中完成的供： 查询是否有IO事件和任务到来 进行事件处理 进行任务处理 下面我们一项项描述。 事件与任务监听简单描述selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())这行代码的含义：如果hasTasks() == true, 调用selector.selectNow()，并清空selectionKeys。因为selector.selectNow()的结果肯定&gt;=0，所以会跳出switch块，否则进入case SelectStrategy.SELECT:分支执行select(wakenUp.getAndSet(false))。这样的好处在于当有task来到的时候，只查询就绪的channel，不阻塞线程；当没有task时，则可以执行NioEventLoop.select()函数，此函数如果没有外部中断或者新任务、定时/周期任务等待处理，会循环执行selector.select(timeoutMillis)去检测网络IO事件。 所以当跳出switch块，则表示有IO事件或者任务到达。 事件处理IO事件到达后，先通过processSelectedKeys()处理IO事件，然后通过runAllTasks处理任务。 1234567891011121314151617181920212223242526272829303132333435//NioEventLoop.java private void processSelectedKeys() &#123; if (selectedKeys != null) &#123; processSelectedKeysOptimized(); &#125; else &#123; processSelectedKeysPlain(selector.selectedKeys()); &#125; &#125; private void processSelectedKeysOptimized() &#123; for (int i = 0; i &lt; selectedKeys.size; ++i) &#123; final SelectionKey k = selectedKeys.keys[i] selectedKeys.keys[i] = null; final Object a = k.attachment(); if (a instanceof AbstractNioChannel) &#123; processSelectedKey(k, (AbstractNioChannel) a); &#125; else &#123; @SuppressWarnings(\"unchecked\") NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a; processSelectedKey(k, task); &#125; if (needsToSelectAgain) &#123; selectedKeys.reset(i + 1); selectAgain(); i = -1; &#125; &#125; &#125; selectedKeys在前面创建NioEventLoop已经初始化过了，所以会调用processSelectedKeysOptimized()函数，但此时第一次进入此函数时selectedKeys是空的，因此直接返回，不处理任何的网络IO事件。虽然目前selectedKeys为空，但还是看看当selectedKeys存储了对应的IO事件时，做了些什么工作： 首先通过selectedKeys.keys[i] = null;清除网络IO事件，然后通过processSelectedKey()处理网络事件和附加的数据a，数据a可以转换为一个AbstractNioChannel或者NioTask&lt;SelectableChannel&gt;。 如果附加的是AbstractNioChannel类型的数据，那么最终processSelectedKey会根据具体的IO事件，通过channel的Unsafe接口去执行具体的读、写、处理连接等工作。 1234567891011121314151617181920212223242526272829//NioEventLoop.java private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) &#123; final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe(); //... try &#123; int readyOps = k.readyOps(); if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123; int ops = k.interestOps(); ops &amp;= ~SelectionKey.OP_CONNECT; k.interestOps(ops); unsafe.finishConnect(); &#125; if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123; ch.unsafe().forceFlush(); &#125; if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123; unsafe.read(); &#125; &#125; catch (CancelledKeyException ignored) &#123; unsafe.close(unsafe.voidPromise()); &#125; &#125; 而如果附加的是NioTask&lt;SelectableChannel&gt;类型的数据，那么processSelectedKey则通过NioTask&lt;SelectableChannel&gt;的channelReady接口完成具体的后续操作。 1234567891011121314151617181920212223242526//NioEventLoop.java private static void processSelectedKey(SelectionKey k, NioTask&lt;SelectableChannel&gt; task) &#123; int state = 0; try &#123; task.channelReady(k.channel(), k); state = 1; &#125; catch (Exception e) &#123; k.cancel(); invokeChannelUnregistered(task, k, e); state = 2; &#125; finally &#123; switch (state) &#123; case 0: k.cancel(); invokeChannelUnregistered(task, k, null); break; case 1: if (!k.isValid()) &#123; // Cancelled by channelReady() invokeChannelUnregistered(task, k, null); &#125; break; &#125; &#125; &#125; 任务处理完成IO事件的处理后，继续往下执行runAllTasks。在处理任务时，需要根据this.ioRatio成员变量控制处理任务的时间百分比。this.ioRatio的默认值为50。也就是说，在事件循环中默认情况下用于处理I/O操作的时间和用于处理任务的时间百分比都为50%。这里我们先看当ioRatio为100的时候是如何执行的: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//SingleThreadEventExecutor.java protected boolean runAllTasks() &#123; assert inEventLoop(); boolean fetchedAll; boolean ranAtLeastOne = false; do &#123; fetchedAll = fetchFromScheduledTaskQueue(); if (runAllTasksFrom(taskQueue)) &#123; ranAtLeastOne = true; &#125; &#125; while (!fetchedAll); // keep on processing until we fetched all scheduled tasks. if (ranAtLeastOne) &#123; lastExecutionTime = ScheduledFutureTask.nanoTime(); &#125; afterRunningAllTasks(); return ranAtLeastOne; &#125; private boolean fetchFromScheduledTaskQueue() &#123; long nanoTime = AbstractScheduledEventExecutor.nanoTime(); Runnable scheduledTask = pollScheduledTask(nanoTime); while (scheduledTask != null) &#123; if (!taskQueue.offer(scheduledTask)) &#123; // No space left in the task queue add it back to the scheduledTaskQueue so we pick it up again. scheduledTaskQueue().add((ScheduledFutureTask&lt;?&gt;) scheduledTask); return false; &#125; scheduledTask = pollScheduledTask(nanoTime); &#125; return true; &#125; protected final boolean runAllTasksFrom(Queue&lt;Runnable&gt; taskQueue) &#123; Runnable task = pollTaskFrom(taskQueue); if (task == null) &#123; return false; &#125; for (;;) &#123; safeExecute(task); task = pollTaskFrom(taskQueue); if (task == null) &#123; return true; &#125; &#125; &#125; runAllTasks()方法通过fetchFromScheduledTaskQueue()方法将所有即将到达执行时间点的周期定时任务从scheduledTaskQueue取出，放到taskQueue中，然后通过runAllTasksFrom(Queue&lt;Runnable&gt; taskQueue)将所有任务一个个取出并执行。这里的循环不会被打断，也就意味着直到所有任务执行完成才会退出。 下面看一下runAllTasks(long timeoutNanos)方法的实现，这也是当前流程中执行的方法： 123456789101112131415161718192021222324252627282930313233343536373839//SingleThreadEventExecutor.java protected boolean runAllTasks(long timeoutNanos) &#123; fetchFromScheduledTaskQueue(); Runnable task = pollTask(); if (task == null) &#123; afterRunningAllTasks(); return false; &#125; final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos; long runTasks = 0; long lastExecutionTime; for (;;) &#123; safeExecute(task); runTasks ++; // Check timeout every 64 tasks because nanoTime() is relatively expensive. // XXX: Hard-coded value - will make it configurable if it is really a problem. if ((runTasks &amp; 0x3F) == 0) &#123; lastExecutionTime = ScheduledFutureTask.nanoTime(); if (lastExecutionTime &gt;= deadline) &#123; break; &#125; &#125; task = pollTask(); if (task == null) &#123; lastExecutionTime = ScheduledFutureTask.nanoTime(); break; &#125; &#125; afterRunningAllTasks(); this.lastExecutionTime = lastExecutionTime; return true; &#125; runAllTasks(long timeoutNanos)首先将所有即将到达执行时间点的周期定时任务从scheduledTaskQueue取出，放到taskQueue中，目前还没有定时和周期任务。然后也会从taskQueue取出每一个task去执行，但是每取出64个（0x100）之后，会进行一次超时判断，如果超时则退出任务的执行。目前taskQueue中存放了一个执行register0方法的任务，所以此任务会出去来准备执行。 切换到子线程继续完成注册当runAllTasks方法内部执行到safeExecute(task)方法时，会调用task.run()方法执行任务的实际工作： 12345678910//AbstractEventExecutor.java protected static void safeExecute(Runnable task) &#123; try &#123; task.run(); &#125; catch (Throwable t) &#123; logger.warn(\"A task raised an exception. Task: &#123;&#125;\", task, t); &#125; &#125; 所以task.run方法此时执行的就是register0(promise)，它是在channel注册时提交的task。 12345678910//AbstractChannel.java try &#123; eventLoop.execute(new Runnable() &#123; @Override public void run() &#123; register0(promise); &#125; &#125;); 因此register0方法实际是在子线程中执行： 1234567891011121314151617181920212223242526272829303132333435363738394041//AbstractChannel.java private void register0(ChannelPromise promise) &#123; try &#123; // check if the channel is still open as it could be closed in the mean time when the register // call was outside of the eventLoop if (!promise.setUncancellable() || !ensureOpen(promise)) &#123; return; &#125; boolean firstRegistration = neverRegistered; doRegister(); neverRegistered = false; registered = true; // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the // user may already fire events through the pipeline in the ChannelFutureListener. pipeline.invokeHandlerAddedIfNeeded(); safeSetSuccess(promise); pipeline.fireChannelRegistered(); // Only fire a channelActive if the channel has never been registered. This prevents firing // multiple channel actives if the channel is deregistered and re-registered. if (isActive()) &#123; if (firstRegistration) &#123; pipeline.fireChannelActive(); &#125; else if (config().isAutoRead()) &#123; // This channel was registered before and autoRead() is set. This means we need to begin read // again so that we process inbound data. // // See https://github.com/netty/netty/issues/4805 beginRead(); &#125; &#125; &#125; catch (Throwable t) &#123; // Close the channel directly to avoid FD leak. closeForcibly(); closeFuture.setClosed(); safeSetFailure(promise, t); &#125; &#125; 这个方法完成了几个动作： promise.setUncancellable()设置注册这个异步操作的promise状态为不可取消的(UNCANCELLABLE)。 通过doRegister方法完成Selector和Channel的绑定。 123456789101112//AbstractNioChannel.java protected void doRegister() throws Exception &#123; //... selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this); //... &#125; protected SelectableChannel javaChannel() &#123; return ch; &#125; javaChannel()接口获取的ch，在NioServerSocketChannel初始化时，创建的实例是ServerSocketChannelImpl，并且已经设置为非阻塞模式。只要调用SelectableChannel的register接口就可以完成注册并返回对应的SelectionKey对象。而实际register方法是在其父类AbstractSelectableChannel中实现，传入的参数为当前NioEventLoop的Selector和Channel实例。 12345678910111213141516171819202122232425262728293031//AbstractSelectableChannel.java public final SelectionKey register(Selector sel, int ops, Object att) throws ClosedChannelException &#123; synchronized (regLock) &#123; if (!isOpen()) throw new ClosedChannelException(); if ((ops &amp; ~validOps()) != 0) throw new IllegalArgumentException(); if (blocking) throw new IllegalBlockingModeException(); SelectionKey k = findKey(sel); if (k != null) &#123; k.interestOps(ops); k.attach(att); &#125; if (k == null) &#123; // New registration synchronized (keyLock) &#123; if (!isOpen()) throw new ClosedChannelException(); k = ((AbstractSelector)sel).register(this, ops, att); addKey(k); &#125; &#125; return k; &#125; &#125; AbstractSelectableChannel.register(Selector sel, int ops, Object att)方法会判断当前的Selector是否已经注册过，如果注册过则将新的监听事件和新的SelectableChannel实例附加到当前的Selector实例中。但是当前我们的Selector还没有注册过，因此执行的分支是调用((AbstractSelector)sel).register(this, ops, att)方法，也就是调用Selector实例的注册方法。而SelectorImpl实现了此方法： 1234567891011//SelectorImpl.java protected final SelectionKey register(AbstractSelectableChannel var1, int var2, Object var3) &#123; //... SelectionKeyImpl var4 = new SelectionKeyImpl((SelChImpl)var1, this); var4.attach(var3); //... var4.interestOps(var2); return var4; &#125; 此方法将Selector和SelectableChannel绑定，设置监听事件，并将this(也就是NioServerSocketChannel)作为附加属性设置到SelectionKey中。 将成员变量registered置为true，表示Channel已经在当前NioEventLoop线程中完成注册。 为注册好的channel的pipeline增加预先定义好的handler，并将下一步要执行的任务添加到NioEventLoop的事件队列。下面开始分析这一系列动作：执行pipeline.invokeHandlerAddedIfNeeded()将在channel初始化时存入链表的PendingHandlerAddedTask取出，并执行其execute()方法，方法会调用ctx.handler().handlerAdded(ctx);，handler()获取到的就是重写了initChannel方法的ChannelInitializer&lt;Channel&gt;的实例，而最终handlerAdded(ctx);就会调用到重写的initChannel方法。这些我们在前面NioServerSocketChannel初始化章节的最后描述过。重写的initChannel方法先将ServerBootstrap中保存的handler加入到pipeline的双向链表中，然后再将一个新的task加入到eventLoop的任务队列中，并会在下一次查询任务队列时被执行。这个任务的作用就是将一个新的handler加入到pipeline的双向链表中。这个handler的类型是ServerBootstrapAcceptor，具体的作用我们等到bind操作完成之后再说。等到将initChannel方法执行完毕之后，这个ChannelInitializerhandler会将自己从pipeline中移除，并将ChannelInitializer关联的ChannelHandlerContext的状态置为REMOVE_COMPLETE。 12345678910111213141516171819//ChannelInitializer.java public abstract class ChannelInitializer&lt;C extends Channel&gt; extends ChannelInboundHandlerAdapter &#123; @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123; if (ctx.channel().isRegistered()) &#123; initChannel(ctx); &#125; &#125; &#125; private boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123; //... initChannel((C) ctx.channel()); //... remove(ctx); //... &#125; 123456789101112131415161718192021//ServerBootstrap.java p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123; @Override public void initChannel(final Channel ch) throws Exception &#123; final ChannelPipeline pipeline = ch.pipeline(); ChannelHandler handler = config.handler(); if (handler != null) &#123; pipeline.addLast(handler); &#125; ch.eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; pipeline.addLast(new ServerBootstrapAcceptor( ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)); &#125; &#125;); &#125; &#125; 标志ChannelPromise(也就是DefaultChannelPromise对象)为成功，也就是将注册这个异步操作标志为成功。 pipeline.fireChannelRegistered()触发ChannelRegistered事件，该事件会在ChannelPipeline中传播。它会先被head处理，随后该事件通过ChannelHandlerContext来实现传递给ChannelPipeline中的下一个ChannelInboundHandler处理器处理，直到最后被tail所处理。到这里initAndRegister()函数执行完毕，意味着channel的注册和初始化完成了。 回到主线程的dobind()回到主线程的dobind()函数，我们一开始就说过，注册这个异步操作根据结果存在两个分支，注册成功直接调用doBind0，否则通过addListener的方式异步执行dobind0。其实只要看注册未完成情况下的分支就可以了。regFuture.addListener创建了一个重写operationComplete接口的ChannelFutureListener。operationComplete()会在regFuture异步操作完成时收到通知。到这里主线程bind()操作完成后，执行sync()阻塞等待。 123456789101112131415161718192021222324252627//AbstractBootstrap.java private ChannelFuture doBind(final SocketAddress localAddress) &#123; //... if (regFuture.isDone()) &#123; ChannelPromise promise = channel.newPromise(); doBind0(regFuture, channel, localAddress, promise); return promise; &#125; else &#123; final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel); regFuture.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) throws Exception &#123; Throwable cause = future.cause(); if (cause != null) &#123; promise.setFailure(cause); &#125; else &#123; promise.registered(); doBind0(regFuture, channel, localAddress, promise); &#125; &#125; &#125;); return promise; &#125; &#125; bossGroup线程继续bind0工作回到bossGroup子线程，往回看register0函数内部的第5个步骤：设置promise为注册成功状态safeSetSuccess(promise);。到这里主线程创建的ChannelFutureListener在此时就会直接在bossGroup子线程内执行operationComplete接口，执行bind0。 123456789101112131415161718//AbstractBootstrap.java private static void doBind0( final ChannelFuture regFuture, final Channel channel, final SocketAddress localAddress, final ChannelPromise promise) &#123; channel.eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; if (regFuture.isSuccess()) &#123; channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE); &#125; else &#123; promise.setFailure(regFuture.cause()); &#125; &#125; &#125;); &#125; bind0将channel的bind操作加入到任务队列中。 NioEventLoop线程继续执行任务队列到这里，我们的NioEventLoop任务队列又多了两个任务： 将ServerBootstrapAcceptor加入到pipeline双向链表中 执行channel.bind操作完成channel端口的绑定 任务一：ServerBootstrapAcceptor实现事件分派先看第一个任务天下的handler。ServerBootstrapAcceptor在channelRead事件触发的时候，把childHandler加到childChannel的Pipeline，设置childChannel的options和attrs，最后执行childChannel的注册来绑定workerGroup的NioEventLoop，并启动workerGroup的事件监听线程。通过这种方式把已经连接的channel的后续IO事件分派给workerGroup进行处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//ServerBootstrap.java private static class ServerBootstrapAcceptor extends ChannelInboundHandlerAdapter &#123; private final EventLoopGroup childGroup; private final ChannelHandler childHandler; private final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions; private final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs; private final Runnable enableAutoReadTask; ServerBootstrapAcceptor( final Channel channel, EventLoopGroup childGroup, ChannelHandler childHandler, Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions, Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs) &#123; this.childGroup = childGroup; this.childHandler = childHandler; this.childOptions = childOptions; this.childAttrs = childAttrs; // Task which is scheduled to re-enable auto-read. // It's important to create this Runnable before we try to submit it as otherwise the URLClassLoader may // not be able to load the class because of the file limit it already reached. // // See https://github.com/netty/netty/issues/1328 enableAutoReadTask = new Runnable() &#123; @Override public void run() &#123; channel.config().setAutoRead(true); &#125; &#125;; &#125; @Override @SuppressWarnings(\"unchecked\") public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; final Channel child = (Channel) msg; child.pipeline().addLast(childHandler); setChannelOptions(child, childOptions, logger); for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123; child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue()); &#125; try &#123; childGroup.register(child).addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) throws Exception &#123; if (!future.isSuccess()) &#123; forceClose(child, future.cause()); &#125; &#125; &#125;); &#125; catch (Throwable t) &#123; forceClose(child, t); &#125; &#125; private static void forceClose(Channel child, Throwable t) &#123; child.unsafe().closeForcibly(); logger.warn(\"Failed to register an accepted channel: &#123;&#125;\", child, t); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; final ChannelConfig config = ctx.channel().config(); if (config.isAutoRead()) &#123; // stop accept new connections for 1 second to allow the channel to recover // See https://github.com/netty/netty/issues/1328 config.setAutoRead(false); ctx.channel().eventLoop().schedule(enableAutoReadTask, 1, TimeUnit.SECONDS); &#125; // still let the exceptionCaught event flow through the pipeline to give the user // a chance to do something with it ctx.fireExceptionCaught(cause); &#125; &#125; 任务二：服务器执行bind操作取出的第二个任务执行channel.bind完成了端口绑定，并增加了ChannelFutureListener.CLOSE_ON_FAILURE监听器监听关闭失败的结果。到这里，整个服务器的启动工作就全部完成了。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"netty","slug":"netty","permalink":"http://yoursite.com/tags/netty/"},{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"}]},{"title":"树莓派开发环境自动配置脚本","slug":"raspberry-autoconfig","date":"2018-12-15T13:46:58.000Z","updated":"2019-01-08T08:11:50.990Z","comments":true,"path":"2018/12/15/raspberry-autoconfig/","link":"","permalink":"http://yoursite.com/2018/12/15/raspberry-autoconfig/","excerpt":"简介在安装完树莓派系统之后，总是需要进行各种环境配置和工具的安装，即浪费时间右容易出错，因此将这些配置都写成了脚本自动化执行，现将脚本写下，供以后参考使用。","text":"简介在安装完树莓派系统之后，总是需要进行各种环境配置和工具的安装，即浪费时间右容易出错，因此将这些配置都写成了脚本自动化执行，现将脚本写下，供以后参考使用。 自动化配置脚本开发环境自动化配置包括：更换软件源、树莓派升级、配套工具安装、开发环境搭建 文件/文件夹 文件 描述 env dhcpcd.confwpa_supplicant.conf 静态网络配置wifi配置 source raspi.listsources.list 软件源配置 totalconfig.sh 总脚本 sourcechange.sh 更换源脚本 sourceupdate.sh 树莓派升级脚本 toolinstall.sh 配套工具安装脚本 envsetting.sh 开发环境搭建脚本 如上表所示，通过一个总脚本totalconfig.sh按顺序进行调用，完成所有配置工作： 123456789#!/bin/bashecho \"开始配置...\"basepath=$(cd `dirname $0`; pwd)source $basepath/sourcechange.shsource $basepath/sourceupdate.shsource $basepath/toolinstall.shsource $basepath/envsetting.shecho \"结束配置...\"reboot 更换软件源sourcechange.sh 12345678#!/bin/bashecho \"启动树莓派源配置...\"basepath=$(cd `dirname $0`; pwd)sudo cp /etc/apt/sources.list /etc/apt/sources.list.baksudo cp /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.list.baksudo cp $basepath/source/sources.list /etc/apt/sources.listsudo cp $basepath/source/raspi.list /etc/apt/sources.list.d/raspi.listecho \"树莓派配置源成功...\" 树莓派升级sourceupdate.sh 1234#!/bin/bashecho \"启动树莓派软件源更新...\"sudo apt-get update &amp;&amp; sudo apt-get -y upgradeecho \"树莓派软件源更新成功...\" 配套工具安装toolinstall.sh 1234#!/bin/bashecho \"安装树莓派应用软件...\"sudo apt-get install -y ttf-wqy-zenhei fcitx fcitx-googlepinyin matchbox-keyboardecho \"树莓派应用软件安装成功...\" 开发环境搭建envsetting.sh 12345678#!/bin/bashecho \"启动树莓派环境配置...\"basepath=$(cd `dirname $0`; pwd)sudo cp /etc/wpa_supplicant/wpa_supplicant.conf /etc/wpa_supplicant/wpa_supplicant.conf.baksudo cp /etc/dhcpcd.conf /etc/dhcpcd.conf.baksudo cp $basepath/env/wpa_supplicant.conf /etc/wpa_supplicant/wpa_supplicant.confsudo cp $basepath/env/dhcpcd.conf /etc/dhcpcd.confecho \"树莓派环境配置成功...\" 软件源配置文件raspi.list 1234567# Uncomment line below then &apos;apt-get update&apos; to enable &apos;apt-get source&apos;#deb-src http://archive.raspberrypi.org/debian/ stretch main ui#deb http://archive.raspberrypi.org/debian/ stretch main ui#清华源testdeb https://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ stretch main uideb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui sources.list 1234567# Uncomment line below then &apos;apt-get update&apos; to enable &apos;apt-get source&apos;#deb http://raspbian.raspberrypi.org/raspbian/ stretch main contrib non-free rpi#deb-src http://raspbian.raspberrypi.org/raspbian/ stretch main contrib non-free rpi#清华源testdeb https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpideb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 静态网络配置文件参考我的另外一篇文档《树莓派内外网连接配置》 wifi配置参考我的另外一篇文档《树莓派3B+踩坑》","categories":[],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/tags/树莓派/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"树莓派内外网连接配置","slug":"raspberry-dhcpcd","date":"2018-12-15T12:41:21.000Z","updated":"2019-01-08T03:37:35.731Z","comments":true,"path":"2018/12/15/raspberry-dhcpcd/","link":"","permalink":"http://yoursite.com/2018/12/15/raspberry-dhcpcd/","excerpt":"网络拓扑在通过树莓派做监控设备时，需要进行内外网数据传输，常用的网络拓扑结构如下：","text":"网络拓扑在通过树莓派做监控设备时，需要进行内外网数据传输，常用的网络拓扑结构如下： 内网主机&lt;—-网线—-&gt;树莓派&lt;—-WIFI—-&gt;4G网卡&lt;=============&gt;互联网 使用这样的网络拓扑结构，树莓派需要进行一些网络配置才能够做到内外网的数据传输。 （在此补充一下4G网卡的选型，之前在某宝买了一款一百多的销量很高的4G网卡，但是不太稳定，虽然卖家服务很好，但是后面还是换成两百多的华为4G网卡，虽然贵了快一倍，但确实比较稳定） 树莓派网络配置在上述的网络拓扑环境下，树莓派通过网线进行内网连接、通过WIFI连接外网。在双网卡的环境下，必须让外网（WIFI）网关作为默认网关，也就是要关闭内网的DHCP默认网关以及动态分配服务，使用静态IP进行内网通信，否则无法上外网。 树莓派配置内网静态IP的方式是通过修改/etc/dhcpcd.conf文件实现，根据直连路由器还是交换机分为两种情况，连接交换机的配置如下： 12345interface eth0static ip_address=192.168.1.158/24static routers=static domain_name_servers=static domain_search= 连接路由器的配置如下： 123456interface eth0nogatewaystatic ip_address=192.168.1.158/24static routers=192.168.1.1static domain_name_servers=static domain_search= nogateway参数的含义，可以参考Ubuntu的dhcp手册：http://manpages.ubuntu.com/manpages/trusty/man8/dhcpcd5.8.html12-G, --nogateway Don&apos;t set any default routes.","categories":[],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/tags/树莓派/"}]},{"title":"IDEA远程调试jar","slug":"java-remotedebug","date":"2018-12-15T12:14:10.000Z","updated":"2019-01-08T03:38:51.591Z","comments":true,"path":"2018/12/15/java-remotedebug/","link":"","permalink":"http://yoursite.com/2018/12/15/java-remotedebug/","excerpt":"远程服务器运行jar包以debug模式启动需要执行java命令时带上以下JVM参数 1java -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,suspend=n,server=y,address=5005 -jar App.jar","text":"远程服务器运行jar包以debug模式启动需要执行java命令时带上以下JVM参数 1java -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,suspend=n,server=y,address=5005 -jar App.jar address为调试端口，可以按实际情况更改 IDEA连接远程端口","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"通过树莓派自启动实现软件远程升级与自动重启","slug":"raspberry-autorestart","date":"2018-12-15T07:08:30.000Z","updated":"2019-01-08T05:48:45.458Z","comments":true,"path":"2018/12/15/raspberry-autorestart/","link":"","permalink":"http://yoursite.com/2018/12/15/raspberry-autorestart/","excerpt":"业务背景在用树莓派做监控设备时，远程控制树莓派是很基本的需求。总体来说包括： 对树莓派本身的控制，比如重启、查看设备状态、修改树莓派配置等。 对业务软件的控制，比如升级、查看软件状态、修改软件配置等。","text":"业务背景在用树莓派做监控设备时，远程控制树莓派是很基本的需求。总体来说包括： 对树莓派本身的控制，比如重启、查看设备状态、修改树莓派配置等。 对业务软件的控制，比如升级、查看软件状态、修改软件配置等。 实现原理无论是哪一种业务，其基本实现原理都是通用的：通过软件作为命令接收终端进行业务拓展。实现的方式和技术选型多种多样，不是本篇的重点，本人使用java作为开发语言，使用Netty接收网络命令进行业务处理。（简单提一句，树莓派自带了jdk，对数据库的操作比较友好，能够节省很多时间）本篇仅考虑软件远程升级这一个业务场景，需要实现的功能包括升级包的接收、组包、存储、升级、重启，前面接收、组包、存储也不是本篇的重点，这里只记录升级和重启这两步在树莓派上的实现方法供以后查阅。 实现方法软件升级和重启这两步可以有几种方式： 直接调用升级程序对软件进行升级和重启，需要实现升级程序，并且考虑好时序问题 先重启树莓派，然后通过树莓派的自启动功能完成升级和重启功能本篇文档采用第二种方式实现 通过java软件重启树莓派通过在jvm中增加一个关闭的钩子RunTime.getRunTime().addShutdownHook，在关闭前创建一个新的线程调用系统重启命令完成树莓派的重启 12345678910Runtime.getRuntime().addShutdownHook(new Thread() &#123; public void run() &#123; try &#123; Runtime.getRuntime().exec(\"reboot\"); &#125; catch (IOException e) &#123; LogHelper.warn(\"执行reboot异常:\" , e); &#125; &#125;&#125;);System.exit(0); 额外说一下，jvm的关闭方式有三种： 正常关闭：当最后一个非守护线程结束或者调用了System.exit或者通过其他特定平台的方法关闭（发送SIGINT，SIGTERM信号等） 强制关闭：通过调用Runtime.halt方法或者是在操作系统中直接kill(发送SIGKILL信号)掉JVM进程 异常关闭：运行中遇到RuntimeException异常等。 配置树莓派自启动比如以pi用户登录，则在/home/pi/.config中创建autostart文件夹，在文件夹下创建jarstart.desktop文件(文件名可以随意,后缀必须为.desktop) 在文件中输入：123[Desktop Entry]Exec=sh /home/pi/Downloads/restart.shType=Application 则在树莓派重启之后会自动调用/home/pi/Downloads/restart.sh脚本，然后通过restart.sh脚本实现升级和启动的操作 脚本实现升级和软件启动比如软件和升级包都放在相同的目录下/home/pi/Downloads，软件名称为App.jar,待升级的软件包叫upgrade.jar，则脚本应该如下： 123456789101112131415161718[Desktop Entry]#!/bin/shcd '/home/pi/Downloads'myFile=\"App.jar\"myUpGradeFile=\"upgrade.jar\"if [ -f \"$myUpGradeFile\" ]; then if [ -f \"$myFile\" ]; then rm -f \"$myFile\"fimv \"$myUpGradeFile\" \"$myFile\"fiif [ -f \"$myFile\" ]; then java -jar \"$myFile\"fi 此脚本先切换到软件目录，并将升级包替换原来的App.jar软件，然后启动App.jar软件，到此完成整个程序的远程升级和重启。","categories":[],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/tags/树莓派/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"树莓派3B+踩坑","slug":"raspberry-start","date":"2018-12-14T14:50:52.000Z","updated":"2019-01-08T05:55:28.705Z","comments":true,"path":"2018/12/14/raspberry-start/","link":"","permalink":"http://yoursite.com/2018/12/14/raspberry-start/","excerpt":"测试可用系统镜像官方系统Raspbain（可用）Ubuntu Mate（官方树莓派镜像16.04.2不可用，本人亲测。需要通过替换Boot和改config的方式安装，网上也有其它方法，但是安装后也并不稳定，因此没有尝试）官方系统能够满足功能需求，所以其它系统没有再测试。","text":"测试可用系统镜像官方系统Raspbain（可用）Ubuntu Mate（官方树莓派镜像16.04.2不可用，本人亲测。需要通过替换Boot和改config的方式安装，网上也有其它方法，但是安装后也并不稳定，因此没有尝试）官方系统能够满足功能需求，所以其它系统没有再测试。 树莓派安装与启动简单记录1.下载官方系统和win32diskimager，通过win32diskimager将系统镜像img文件写入SD卡中 2.进入SD卡boot分区，编辑config.txt文件，按照购买的树莓派屏幕尺寸更改相应配置 屏幕尺寸 配置 3.5寸 hdmi_force_hotplug=1max_usb_current=1hdmi_group=2hdmi_mode=87hdmi_cvt 800 600 60 6 0 0 0hdmi_drive=1 7寸 max_usb_current=1hdmi_group=2hdmi_mode=87hdmi_cvt 1024 600 60 6 0 0 0hdmi_drive=1 3.开启SSH 在SD卡boot分区里面创建一个名为 “ssh” 空文件即可（不要有txt后缀！） 4.如果没有网线只有wifi，可以在启动前先设置好wifi连接：在SD卡boot分区新建一个wpa_supplicant.conf文件，写入上网配置命令 12345678910country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123; ssid=&quot;wifi_name&quot; psk=&quot;password&quot; key_mgmt=WPA-PSK priority=1&#125; 在树莓派通电后会自动添加到/etc/wpa_supplicant/wpa_supplicant.conf文件里面，上电后会自动连接。 这里注意一定要在boot目录下创建这个文件，否则系统装好后将无法启动wifi连接。 5.做好这些后，将SD卡插入树莓派，启动系统 远程连接树莓派首次启动之后，先接上USB鼠标查看当前的网络连接分配的IP地址（无线网络需要在启动前配置好wifi的用户名密码才能自动连接，否则这里需要外接键盘输入wifi密码）。 有了IP地址就可以用过SSH远程连接进入控制台。当然最好是启用树莓派自带的VNC服务，然后通过电脑的VNC Viewer远程连接上树莓派，就可以进入带界面的树莓派系统。 更换软件源以下更改都是针对stretch版本版本更换软件源，一般只用一个即可，常用中科大的Raspbian源（中科大后面不能用，现在改成清华的源）： 修改系统源：/etc/apt/sources.list.d/raspi.list 12345#中科大 #deb https://mirrors.ustc.edu.cn/archive.raspberrypi.org/ stretch main ui #清华 deb https://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ stretch main uideb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui 中文显示与输入首先在系统界面中选择中文 但是CPU利用率仍然无法显示。需要打开命令终端进行中文字体安装，在终端中输入 1sudo apt-get install ttf-wqy-zenhei 安装完成之后重启，CPU利用率即可显示。 安装fcitx输入法，并安装谷歌输入法模块，在命令行中输入以下命令 1sudo apt-get install fcitx fcitx-googlepinyin 如果不想经常外接键盘，需要安装虚拟键盘和对应的字体 1sudo apt-get install matchbox-keyboard 1sudo apt-get -y install ttf-wqy-zenhei 安装完成之后，在下图位置启动 非原装3.5寸LCD屏幕驱动安装树莓派自带的3.5寸的触摸屏，通过GPIO口连接。但是淘宝上面的这款产品其实是要安装触摸屏的驱动的。 首先下载触摸屏驱动 https://github.com/goodtft/LCD-show参考安装文档如下：www.kedei.net/raspberry/raspberry.html http://www.waveshare.net/wiki/3.5inch_HDMI_LCD 简单描述一下：将下载的驱动解压，通过XShell的Xftp先传到Downloads目录下（直接传输到boot目录没有权限），然后通过cp命令将文件夹拷贝到boot目录下 1sudo cp -r LCD-show /boot/ 然后确认是要通过何种型号，执行命令 1./MPI3508_480_320-show 然后在LCD-show文件夹中有校准工具xinput-calibrator_0.7.5-1_armhf.deb，通过命令安装校准工具 1$dpkg -i -B xinput-calibrator_0.7.5-1_armhf.deb 然后通过界面“首选项”中打开Calibrate TouchScreen，按照界面要求点击，最终会出现一个校准后的结果。 再将结果通过root用户权限改写原来的校准值 1sudo nano /etc/X11/xorg.conf.d/99-calibration.conf 另外，虽然3.5寸屏幕硬件分辨率为480X320，但是可以通过界面修改软件分辨率，CEA为电视机标准，DMT是电脑显示器标准，他们分别有不一样的分辨率，可以按照当前显示输出设备，选择一个合适的分辨率","categories":[],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://yoursite.com/tags/树莓派/"}]}]}