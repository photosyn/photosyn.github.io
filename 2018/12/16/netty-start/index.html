<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="ServerBootStrap示例了解netty服务器的启动，从官方提供的4.1版本echo服务器端代码开始。">
<meta name="keywords" content="java,netty,服务器">
<meta property="og:type" content="article">
<meta property="og:title" content="netty启动详细记录">
<meta property="og:url" content="http://yoursite.com/2018/12/16/netty-start/index.html">
<meta property="og:site_name" content="photosyn&#39;s blog">
<meta property="og:description" content="ServerBootStrap示例了解netty服务器的启动，从官方提供的4.1版本echo服务器端代码开始。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2018/12/16/netty-start/netty服务器启动流程图.jpg">
<meta property="og:image" content="http://yoursite.com/2018/12/16/netty-start/NioServerSocketChannel.jpg">
<meta property="og:image" content="http://yoursite.com/2018/12/16/netty-start/NioServerSocketChannel实例化.jpg">
<meta property="og:image" content="http://yoursite.com/2018/12/16/netty-start/sp181225_142451.png">
<meta property="og:image" content="http://yoursite.com/2018/12/16/netty-start/sp181225_142801.png">
<meta property="og:image" content="http://yoursite.com/2018/12/16/netty-start/sp181225_150212.png">
<meta property="og:image" content="http://yoursite.com/2018/12/16/netty-start/NioEventLoopGroup.jpg">
<meta property="og:image" content="http://yoursite.com/2018/12/16/netty-start/NioEventLoopGroup实例化.png">
<meta property="og:image" content="http://yoursite.com/2018/12/16/netty-start/NioEventLoop.png">
<meta property="og:image" content="http://yoursite.com/2018/12/16/netty-start/NioEventLoop实例化.png">
<meta property="og:updated_time" content="2019-01-08T05:47:56.329Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="netty启动详细记录">
<meta name="twitter:description" content="ServerBootStrap示例了解netty服务器的启动，从官方提供的4.1版本echo服务器端代码开始。">
<meta name="twitter:image" content="http://yoursite.com/2018/12/16/netty-start/netty服务器启动流程图.jpg">






  <link rel="canonical" href="http://yoursite.com/2018/12/16/netty-start/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>netty启动详细记录 | photosyn's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">photosyn's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">keep learning</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/16/netty-start/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="photosyn">
      <meta itemprop="description" content="学习，生活">
      <meta itemprop="image" content="/images/7.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="photosyn's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">netty启动详细记录

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-16 21:03:09" itemprop="dateCreated datePublished" datetime="2018-12-16T21:03:09+08:00">2018-12-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-08 13:47:56" itemprop="dateModified" datetime="2019-01-08T13:47:56+08:00">2019-01-08</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="ServerBootStrap示例"><a href="#ServerBootStrap示例" class="headerlink" title="ServerBootStrap示例"></a>ServerBootStrap示例</h3><p>了解netty服务器的启动，从官方提供的4.1版本echo服务器端代码开始。<br><a id="more"></a></p>
<figure class="highlight java"><figcaption><span>Netty官方echo示例</span><a href="https://github.com/netty/netty/blob/4.1/example/src/main/java/io/netty/example/echo/EchoServer.java" target="_blank" rel="noopener">EchoServer.java</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SSL = System.getProperty(<span class="string">"ssl"</span>) != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">"port"</span>, <span class="string">"8007"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Configure SSL.</span></span><br><span class="line">        <span class="keyword">final</span> SslContext sslCtx;</span><br><span class="line">        <span class="keyword">if</span> (SSL) &#123;</span><br><span class="line">            SelfSignedCertificate ssc = <span class="keyword">new</span> SelfSignedCertificate();</span><br><span class="line">            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sslCtx = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure the server.</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">             .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     ChannelPipeline p = ch.pipeline();</span><br><span class="line">                     <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">                     p.addLast(serverHandler);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start the server.</span></span><br><span class="line">            ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这篇文章关心的是netty服务器是如何启动的。因此先跳过<code>bossGroup</code>、<code>workerGroup</code>的创建细节和<code>ServerBootstrap</code>参数初始化细节，直接看<code>bind</code>接口，这里是真正服务器启动的地方。然后顺着netty启动的顺序，遇到新的知识点再展开描述与记录。</p>
<h3 id="整体启动脉络"><a href="#整体启动脉络" class="headerlink" title="整体启动脉络"></a>整体启动脉络</h3><p>netty启动涉及到多线程，为了便于以后快速回顾，先将整体启动的大致过程记录下来。绿色部分是给子线程分配的关键初始化任务。</p>
<img src="/2018/12/16/netty-start/netty服务器启动流程图.jpg" title="netty启动流程图">
<h3 id="netty启动相关类介绍"><a href="#netty启动相关类介绍" class="headerlink" title="netty启动相关类介绍"></a>netty启动相关类介绍</h3><p>一开始虽然不会详细介绍<code>bossGroup</code>、<code>workerGroup</code>和<code>ServerBootstrap</code>的细节，但是还是先要对启动相关类有个基本认识。</p>
<ul>
<li><code>ServerBootstrap</code>：为了简化服务器启动过程，所有启动相关的接口和参数都封装到这里，相当于一个门面(Facade)模式。</li>
<li><code>Channel</code>：是netty的核心接口类，除了提供IO操作的接口之外，还提供对于核心组件的访问接口。如果把netty比作一台机器可以说是<code>Channel</code>将机器上所有的基本零件连接在了一起。</li>
<li><code>ChannelFuture</code>：通过它可以读取<code>Channel</code>中的异步操作的状态和结果，简单描述可以分为uncompleted和completed两种情况，而completed又包括Completed successfully、Completed with failure 、Completed by cancellation三种状态。另外它也可以添加ChannelFutureListener监听器，来监听异步I/O操作结果并执行后续操作。</li>
<li><code>ChannelPromise</code>：可以设置异步操作的状态和结果的一种特殊<code>ChannelFuture</code>。在启动过程中会用到它的默认实现<code>DefaultChannelPromise</code>。</li>
<li><code>DefaultChannelPromise</code>：在设置异步IO操作成功或者失败之后会通知相应的listeners的默认<code>ChannelPromise</code>。</li>
</ul>
<h3 id="服务器的启动入口"><a href="#服务器的启动入口" class="headerlink" title="服务器的启动入口"></a>服务器的启动入口</h3><p>直接看<code>bind</code>操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServerBootstrap.java</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the server.</span></span><br><span class="line">    ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>bind</code>方法调用基类<code>AbstractBootstrap</code>的<code>bind</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBootstrap.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//验证服务启动的必要参数</span></span><br><span class="line">        validate();</span><br><span class="line">        <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"localAddress"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doBind(localAddress);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>bind方法继续调用doBind方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBootstrap.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> regFuture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">            <span class="comment">// At this point we know that the registration was complete and successful.</span></span><br><span class="line">            ChannelPromise promise = channel.newPromise();</span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Registration future is almost always fulfilled already, but just in case it's not.</span></span><br><span class="line">            <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">            regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    Throwable cause = future.cause();</span><br><span class="line">                    <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line">                        <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line">                        promise.setFailure(cause);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                        <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">                        promise.registered();</span><br><span class="line"></span><br><span class="line">                        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>doBind</code>方法最终调用<code>doBind0</code>方法。<br>这里<code>regFuture</code>其实是记录注册异步操作结果的<code>ChannelPromise</code>实例，通过<code>regFuture.isDone()</code>判断注册异步操作是否完成，存在两种情况：</p>
<ul>
<li>注册操作没有完成：先给<code>regFuture</code>增加一个监听器，如果注册成功没有错，就会在设置<code>regFuture</code>结果的地方调用<code>doBind0</code>方法</li>
<li>注册操作已经完成，则立即调用<code>doBind0</code>方法</li>
</ul>
<p>两者的区别在于调用此方法的线程不同。注册完成就直接在主线程调用，没有完成其实是在<code>workGroup</code>子线程中通过触发linster回调doBind0方法。但是殊途同归的是最终真正执行bind操作的地方都是在<code>workGroup</code>子线程中。</p>
<h4 id="initAndRegister方法"><a href="#initAndRegister方法" class="headerlink" title="initAndRegister方法"></a>initAndRegister方法</h4><p>调用<code>doBind0</code>方法之前，<code>regFuture</code>和<code>channel</code>参数都是通过<code>initAndRegister</code>方法创建的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBootstrap.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>initAndRegister</code>方法内部主要完成了三件事</p>
<ol>
<li>创建channel</li>
<li>初始化channel</li>
<li>返回注册的异步结果regFuture</li>
</ol>
<p>我们先看如何创建channel。</p>
<h3 id="确定创建的channel类型"><a href="#确定创建的channel类型" class="headerlink" title="确定创建的channel类型"></a>确定创建的channel类型</h3><p>channel是通过<code>channelFactory.newChannel()</code>方法完成创建的，那<code>channelFactory</code>是如何创建的，对象的类型是什么？<br>其实通过代码可以确定<code>channelFactory</code>对象实际的类型是<code>ReflectiveChannelFactory</code>。它通过<br><code>ServerBootstrap</code>的<code>channel</code>接口完成创建和赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.channel(NioSocketChannel.class)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBootstrap.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channelClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"channelClass"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channelFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"channelFactory"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.channelFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"channelFactory set already"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.channelFactory = channelFactory;</span><br><span class="line">        <span class="keyword">return</span> self();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>ReflectiveChannelFactory</code>的<code>newChannel</code>方法通过反射的方式创建对象，创建的对象类型为通过构造函数传入的类类型，也就是<code>NioSocketChannel.class</code>类型。因此只要通过<code>ServerBootstrap</code>的<code>channel</code>接口传入具体的类，就决定Netty服务器创建的<code>Channel</code>类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveChannelFactory</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">ChannelFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends T&gt; clazz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"clazz"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz.getConstructor().newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Unable to create Channel from class "</span> + clazz, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="NioServerSocketChannel扩展理解"><a href="#NioServerSocketChannel扩展理解" class="headerlink" title="NioServerSocketChannel扩展理解"></a>NioServerSocketChannel扩展理解</h3><p><code>Channel</code>作为netty的核心组件之一，为了加深理解，我们先做简单的介绍：</p>
<ul>
<li>NioSocketChannel, 代表异步的客户端 TCP Socket 连接</li>
<li>NioServerSocketChannel, 异步的服务器端 TCP Socket 连接</li>
<li>NioDatagramChannel, 异步的 UDP 连接</li>
<li>NioSctpChannel, 异步的客户端 Sctp 连接</li>
<li>NioSctpServerChannel, 异步的 Sctp 服务器端连接</li>
<li>OioSocketChannel, 同步的客户端 TCP Socket 连接</li>
<li>OioServerSocketChannel, 同步的服务器端 TCP Socket 连接</li>
<li>OioDatagramChannel, 同步的 UDP 连接</li>
<li>OioSctpChannel, 同步的 Sctp 服务器端连接</li>
<li>OioSctpServerChannel, 同步的客户端 TCP Socket 连接</li>
</ul>
<p><code>Channel</code>层级结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannel</span><br><span class="line">|</span><br><span class="line">|--AbstractNioChannel</span><br><span class="line">|   |--AbstractNioByteChannel</span><br><span class="line">|      |--NioSocketChannel</span><br><span class="line">|</span><br><span class="line">|--AbstractNioMessageChannel</span><br><span class="line">|   |--NioServerSocketChannel</span><br><span class="line">|      |--NioDatagramChannel</span><br><span class="line">|      |--NioSctpServerChannel</span><br><span class="line">|      |--NioSctpChannel</span><br><span class="line">|</span><br><span class="line">|--AbstractOioChannel</span><br><span class="line">|    |--AbstractOioByteChannel</span><br><span class="line">|        |--OioByteStreamChannel</span><br><span class="line">|            |--OioSocketChannel</span><br><span class="line">|</span><br><span class="line">|--AbstractOioMessageChannel</span><br><span class="line">|   |--OioServerSocketChannel</span><br><span class="line">|       |--OioDatagramChannel</span><br><span class="line">|       |--OioSctpServerChannel</span><br><span class="line">|       |--OioSctpChannel</span><br></pre></td></tr></table></figure>
<p>以上channel可以理解为netty对传输层的具体实现，而<code>AbstractChannel</code>是netty对传输层的抽象，但是也通过采用Facade模式聚合了很多内部组件，包括了<code>Unsafe</code>、<code>ChannelPipeline</code>、<code>EventLoop</code>、<code>ChannelPromise</code>等，对外提供了统一接口。</p>
<p>而在<code>AbstractChannel</code>层次之上又分为<code>AbstractOioChannel</code>（阻塞）和<code>AbstractNioChannel</code>（非阻塞）。他们的最大的区别在于<code>AbstractNioChannel</code>类内部存在一个<code>SelectableChannel</code>类型的成员变量。<code>SelectableChannel</code>是一个可以通过<code>Selector</code>来进行多路复用的通道。</p>
<h3 id="AbstractChannel核心类介绍"><a href="#AbstractChannel核心类介绍" class="headerlink" title="AbstractChannel核心类介绍"></a>AbstractChannel核心类介绍</h3><p>在继续<code>NioServerSocketChannel</code>的创建之前，我们再看看<code>AbstractChannel</code>核心组件：</p>
<ul>
<li><code>ChannelId</code>：每个Channel的唯一标识，这个唯一标识通过<code>DefaultChannelId</code>产生。</li>
<li><code>Unsafe</code>：它是<code>Channel</code>的辅助接口，不应该被用户代码直接使用，而实际的IO操作应该都由<code>Unsafe</code>接口负责完成。</li>
<li><code>DefaultChannelPipeline</code>：维护一个<code>AbstractChannelHandlerContext</code>的链表，通过这个链表中的handler处理器来处理Channel上的数据。<code>AbstractChannelHandlerContext</code>放到pipeline部分再详细介绍。</li>
<li><code>EventLoop</code>：主要负责执行Channel生命周期内的事件轮询和各种任务。</li>
</ul>
<h3 id="AbstractNioChannel核心类介绍"><a href="#AbstractNioChannel核心类介绍" class="headerlink" title="AbstractNioChannel核心类介绍"></a>AbstractNioChannel核心类介绍</h3><ul>
<li><code>SelectableChannel</code>：是java nio中的抽象类，本身可以通过<code>Selector</code>来支持多路复用通道，且提供两种模式Blocking mode和Non-blocking mode，<code>SelectableChannel</code>的Non-blocking mode是实现Netty的异步IO事件机制的基础。而要使用Non-blocking mode，需要先设置为Non-blocking mode模式，再通过<code>register(Selector,int,Object)</code>接口绑定<code>Selector</code>并拿到返回的<code>SelectionKey</code>对象。</li>
<li><code>SelectionKey</code>：<code>SelectableChannel</code>与<code>Selector</code>注册的标识。</li>
</ul>
<h3 id="NioServerSocketChannel核心类介绍"><a href="#NioServerSocketChannel核心类介绍" class="headerlink" title="NioServerSocketChannel核心类介绍"></a>NioServerSocketChannel核心类介绍</h3><ul>
<li><code>ChannelConfig</code>：操作Channel的配置属性集的接口，包括<code>ChannelOption</code>配置和传输相关的属性。</li>
<li><p><code>ChannelOption</code>：提供一种类型安全的方式来表现配置信息。比如配置超时时间<code>CONNECT_TIMEOUT_MILLIS</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final ChannelOption&lt;Integer&gt; CONNECT_TIMEOUT_MILLIS = valueOf(&quot;CONNECT_TIMEOUT_MILLIS&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DefaultChannelConfig</code>：对于<code>ChannelConfig</code>的默认实现，内部实现了对各种<code>ChannelOption</code>类型的统一访问，实现了对<code>ByteBufAllocator</code>的访问，以及<code>Channel</code>中的各种默认配置的访问，如读取数据长度、连接超时时间等。</p>
</li>
<li><code>DefaultServerSocketChannelConfig</code>：<code>DefaultChannelConfig</code>的子类，实现了通过<code>ServerSocketChannelConfig</code>提供的扩展接口，内部存储了<code>ServerSocket</code>的实例。</li>
<li><code>NioServerSocketChannelConfig</code>：<code>DefaultServerSocketChannelConfig</code>的子类，实现了<code>autoReadCleared</code>接口。</li>
</ul>
<h3 id="NioServerSocketChannel的类图"><a href="#NioServerSocketChannel的类图" class="headerlink" title="NioServerSocketChannel的类图"></a>NioServerSocketChannel的类图</h3><img src="/2018/12/16/netty-start/NioServerSocketChannel.jpg" title="NioServerSocketChannel类图">
<h3 id="创建NioServerSocketChannel"><a href="#创建NioServerSocketChannel" class="headerlink" title="创建NioServerSocketChannel"></a>创建NioServerSocketChannel</h3><img src="/2018/12/16/netty-start/NioServerSocketChannel实例化.jpg" title="NioServerSocketChannel实例化">
<p>通过工厂模式创建的<code>NioServerSocketChannel</code>调用的是默认的构造函数，而默认构造函数内部调用了带参数的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioServerSocketChannel.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">        config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>DEFAULT_SELECTOR_PROVIDER</code>是通过<code>SelectorProvider.provider()</code>创建的类静态变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SelectorProvider.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultSelectorProvider.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowsSelectorProvider();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>channel的创建和平台相关，都是通过对应平台的provider来创建平添相关的channel，以windows平台为例：<br><code>DEFAULT_SELECTOR_PROVIDER</code>对象的实际类型是<code>WindowsSelectorProvider</code>。<br>因此<code>newSocket</code>方法调用的<code>provider.openServerSocketChannel</code>方法，在<code>WindowsSelectorProvider</code>父类<code>SelectorProviderImpl</code>中被实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioServerSocketChannel.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(</span><br><span class="line">                    <span class="string">"Failed to open a server socket."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WindowsSelectorImpl.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerSocketChannel <span class="title">openServerSocketChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerSocketChannelImpl(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>ServerSocketChannelImpl</code>类内部通过<code>Net</code>组件来实现对本地socket的操作。</p>
<p>所以回到<code>this()</code>构造函数的调用，实际传入的实参类型为<code>ServerSocketChannelImpl</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioServerSocketChannel.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">        config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到这里直接参考<code>NioServerSocketChannel</code>实例化流程图可以基本理解<code>NioServerSocketChannel</code>实例化过程。</p>
<p>过程中有几点还是记录下来：</p>
<ul>
<li><code>ServerSocketChannelImpl</code>保存到<code>this.ch</code>中，转换成了<code>SelectableChannel</code>类型。</li>
<li>初始化过程中通过<code>ch.configureBlocking(false);</code>将<code>AbstractSelectableChannel</code>的<code>blocking</code>字段设为false，也就是将<code>ch</code>设置为非阻塞模式。后面只要调用<code>register</code>接口就可以完成channel和selector的注册。</li>
<li>创建的<code>NioServerSocketChannelConfig</code>对象的成员变量<code>channel</code>和<code>javaSocket</code>对应的实例对象为<code>NioServerSocketChannel</code>和经过<code>ServerSocketAdaptor</code>类型转换后的<code>ServerSocket</code>，实际上还是<code>ServerSocketChannelImpl</code>。</li>
<li><code>unsafe</code>实际对应的是<code>NioMessageUnsafe</code>。<code>NioMessageUnsafe</code>重写了<code>read</code>接口，<code>read</code>方法通过<code>doReadMessages()</code>处理<code>NioServerSocketChannel</code>的accept操作。如果此时没有客户端连接，则退出for循环进行后续的处理，如果有客户端连接，则将客户端<code>NioSocketChannel</code>保存到readBuf中（默认不超过16个），如果超过16个，则也退出for循环进行后续的处理。最后将readBuf传到<code>pipeline</code>去解析。</li>
</ul>
<h3 id="pipeline的创建"><a href="#pipeline的创建" class="headerlink" title="pipeline的创建"></a>pipeline的创建</h3><p>其中pipeline是很重要的组件，所以再详细看一下pipeline的创建。</p>
<p>先介绍pipeline的核心类：</p>
<ul>
<li><code>AttributeKey</code>：用于从AttributeMap中访问<code>Attribute</code>的键</li>
<li><code>Attribute</code>：存储与操作泛型数据的接口</li>
<li><code>AttributeMap</code>：提供通过<code>AttributeKey</code>来获取<code>Attribute</code>类型的value的接口。</li>
<li><code>DefaultAttributeMap</code>：<code>AttributeMap</code>的的默认实现，用来存取<code>AttributeMap</code>的数据。</li>
<li><code>ChannelInboundInvoker</code>：定义了<code>ChannelHandlerContext</code>传递inbound事件的方法。</li>
<li><code>ChannelOutboundInvoker</code>：定义了<code>ChannelHandlerContext</code>传递outbound事件的接口。</li>
<li><code>ChannelHandlerContext</code>：提供了访问各种资源如<code>Channel</code>、<code>ChannelHandler</code>、<code>EventExecutor</code>、<code>ChannelPipeline</code>、<code>ByteBufAllocator</code>、<code>Attribute</code>的方法，并且实现了<code>ChannelInboundInvoker</code>和<code>ChannelOutboundInvoker</code>来规范inbound和outbound事件的处理接口。</li>
<li><code>AbstractChannelHandlerContext</code>：它继承了<code>DefaultAttributeMap</code>，因此它有存取<code>AttributeMap</code>数据的能力，同时它也实现了<code>ChannelHandlerContext</code>接口，因此它也拥有访问pipeline的各种资源的能力。</li>
</ul>
<p>这里还要补充一下，<code>Channel</code>和<code>AbstractChannelHandlerContext</code>都实现了<code>AttributeMap</code>接口，因此每一个<code>Channel</code>和<code>ChannelHandlerContext</code>实例都可以像Map一样来存取key和value，唯一的区别是<code>ChannelHandlerContext</code>的<code>AttributeMap</code>仅用于当前具体的<code>ChannelHandler</code>子类实例，而<code>Channel</code>的<code>AttributeMap</code>可以被用于所有的<code>ChannelHandlerContext</code>链表中的<code>ChannelHandler</code>子类实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannel.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelPipeline.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">        succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">        voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">        head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建过程比较简单：</p>
<ul>
<li><code>DefaultChannelPipeline</code>绑定的channel就是<code>NioServerSocketChannel</code>，并创建了<code>succeededFuture</code>、<code>voidPromise</code>用于异步操作支持。</li>
<li>创建<code>TailContext</code>和<code>HeadContext</code>来填充<code>AbstractChannelHandlerContext</code>链表结构，channel的handler都会放到这个链表。</li>
</ul>
<h3 id="NioServerSocketChannel的初始化"><a href="#NioServerSocketChannel的初始化" class="headerlink" title="NioServerSocketChannel的初始化"></a>NioServerSocketChannel的初始化</h3><p>完成了<code>NioServerSocketChannel</code>的创建之后，接着执行<code>NioServerSocketChannel</code>的初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServerBootstrap.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">            channel.attr(key).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (childAttrs) &#123;</span><br><span class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初始化完成了几个工作</p>
<ol>
<li>如果用户代码有调用<code>AbstractBootstrap.option</code>接口保存<code>ChannelOption</code>，那么这里将<code>ChannelOption</code>用来配置<code>NioServerSocketChannel</code>的config对象。</li>
<li>如果用户代码有调用<code>AbstractBootstrap.attr</code>接口保存<code>AttributeKey</code>和<code>Attribute</code>，那么这里将保存的<code>AttributeKey</code>和<code>Attribute</code>键值对复制到channel。</li>
<li><code>ChannelInitializer&lt;Channel&gt;()</code>对象的基类是<code>ChannelHandler</code>，最终会封装到一个<code>AbstractChannelHandlerContext</code>对象内部，再加入到<code>pipeline</code>双向链表中。</li>
<li>调用<code>addLast</code>接口时，由于<code>NioServerSocketChannel</code>还没有注册完成，所以会额外创建一个封装了<code>ChannelInitializer&lt;Channel&gt;()</code>的<code>AbstractChannelHandlerContext</code>对象，并加入到一个新的<code>PendingHandlerAddedTask</code>对象中，再将此对象加入到pipeline的<code>pendingHandlerCallbackHead</code>单项链表上。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelPipeline.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addLast(<span class="keyword">null</span>, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addLast(<span class="keyword">null</span>, name, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line">            newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line">            addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// registered 为 false 标识channel还没有注册到eventloop中。</span></span><br><span class="line">            <span class="comment">// 这种情况下处理会在pipeline中加入一个context外，还添加了一个task，当channel注册完成的时候，这个task会执行</span></span><br><span class="line">            ChannelHandler.handlerAdded(...)。</span><br><span class="line">            <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EventExecutor executor = newCtx.executor();</span><br><span class="line">            <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        callHandlerAdded0(newCtx);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        callHandlerAdded0(newCtx);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerCallbackLater</span><span class="params">(AbstractChannelHandlerContext ctx, <span class="keyword">boolean</span> added)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> !registered;</span><br><span class="line"></span><br><span class="line">        PendingHandlerCallback task = added ? <span class="keyword">new</span> PendingHandlerAddedTask(ctx) : <span class="keyword">new</span> PendingHandlerRemovedTask(ctx);</span><br><span class="line">        PendingHandlerCallback pending = pendingHandlerCallbackHead;</span><br><span class="line">        <span class="keyword">if</span> (pending == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pendingHandlerCallbackHead = task;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Find the tail of the linked-list.</span></span><br><span class="line">            <span class="keyword">while</span> (pending.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pending = pending.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pending.next = task;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>提前说明这个<code>PendingHandlerAddedTask</code>的作用：<br>存入<code>pendingHandlerCallbackHead</code>链表的<code>PendingHandlerAddedTask</code><br>等到channel注册完成之后会取出并执行。执行时调用<code>PendingHandlerAddedTask</code>的<code>execute</code>方法，此方法先调用<code>callHandlerAdded0</code>，<code>callHandlerAdded0</code>再调用<code>ctx.handler().handlerAdded(ctx);</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelPipeline.java</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingHandlerAddedTask</span> <span class="keyword">extends</span> <span class="title">PendingHandlerCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            callHandlerAdded0(ctx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            EventExecutor executor = ctx.executor();</span><br><span class="line">            <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">                callHandlerAdded0(ctx);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    executor.execute(<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                        logger.warn(</span><br><span class="line">                                <span class="string">"Can't invoke handlerAdded() as the EventExecutor &#123;&#125; rejected it, removing handler &#123;&#125;."</span>,</span><br><span class="line">                                executor, ctx.name(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    remove0(ctx);</span><br><span class="line">                    ctx.setRemoved();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAdded0</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ctx.setAddComplete();</span><br><span class="line">            ctx.handler().handlerAdded(ctx);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中<code>ctx.handler()</code>是<code>ChannelInitializer</code>，而<code>ctx.handler().handlerAdded(ctx);</code>实际上调用的是<code>initChannel</code>接口。而在channel注册时创建的<code>ChannelInitializer&lt;Channel&gt;()</code>刚好重写了此接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ChannelInitializer.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">            initChannel(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所以等到channel注册完成之后，会调用<code>ChannelInitializer&lt;Channel&gt;()</code>重写的<code>initChannel</code>方法执行channel的额外初始化。这部分初始化代码等到注册完成时再说。</p>
<h3 id="NioServerSocketChannel注册入口"><a href="#NioServerSocketChannel注册入口" class="headerlink" title="NioServerSocketChannel注册入口"></a>NioServerSocketChannel注册入口</h3><p>完成了<code>NioServerSocketChannel</code>的初始化之后，返回到<code>initAndRegister</code>方法继续往下看注册流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture regFuture = config().group().register(channel);</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>config()</code>是<code>ServerBootstrap</code>的内部成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final ServerBootstrapConfig config = new ServerBootstrapConfig(this);</span><br></pre></td></tr></table></figure></p>
<p><code>config().group()</code>对应的是<code>AbstractBootstrap</code>的group成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBootstrapConfig.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> EventLoopGroup <span class="title">group</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bootstrap.group();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBootstrap.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> EventLoopGroup <span class="title">group</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> group;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而group成员变量是通过<code>ServerBootstrap</code>的<code>group</code>方法初始化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServerBootstrap.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">        <span class="keyword">if</span> (childGroup == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"childGroup"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"childGroup set already"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在示例代码中对应的是<code>bossGroup</code>，而其<code>childGroup</code>成员变量保存的是<code>workerGroup</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.group(bossGroup, workerGroup)</span><br></pre></td></tr></table></figure></p>
<p>它们是通过<code>NioEventLoopGroup</code>创建的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到这里我们又进入了另一大Netty的核心：<code>EventLoop</code>和<code>EventLoopGroup</code>，待会会详细介绍。</p>
<p>最终<code>config().group().register(channel)</code>函数实际上调用的是<code>NioEventLoopGroup</code>的<code>register</code>方法，但实现是在父类<code>MultithreadEventLoopGroup</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultithreadEventLoopGroup.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next().register(channel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventLoop <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (EventLoop) <span class="keyword">super</span>.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而<code>MultithreadEventLoopGroup</code>实际上也不是直接注册，而是通过父类的<code>next</code>接口获取到一个<code>EventExecutor</code>并转换为<code>EventLoop</code>类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultithreadEventExecutorGroup.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> chooser.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看到这里出现了<code>chooser</code>、<code>EventExecutor</code>以及<code>EventLoop</code>这些新的组件，以及一开始创建的两个<code>NioEventLoopGroup</code>对象<code>bossGroup</code>和<code>workerGroup</code>，而为了便于理解这部分内容，在接着看注册流程之前，必须先对netty的线程模型有个基本的认识。<br>如果对<code>NioEventLoopGroup</code>和<code>NioEventLoop</code>有了基本的认识，则可以跳过直接看<code>继续Channel的注册流程</code>的章节。</p>
<h3 id="Reactor模型的理解"><a href="#Reactor模型的理解" class="headerlink" title="Reactor模型的理解"></a>Reactor模型的理解</h3><p>对<code>NioEventLoopGroup</code>的理解参考了此篇文章：<a href="https://segmentfault.com/a/1190000007403873" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007403873</a></p>
<p>要理解<code>NioEventLoopGroup</code>，首先还是要知道Netty线程模型是Reactor设计模式的一个实现。<br>Reactor设计模式中有两个重要角色：</p>
<ul>
<li>Reactor的职责是检测网络IO事件并分发给合适的handler处理。</li>
<li>Handlers的职责是执行非阻塞的行为。</li>
</ul>
<p>而Reactor设计模式根据线程的数量和作用又分为三种Reactor线程模型</p>
<ul>
<li>单线程模型</li>
<li>多线程模型</li>
<li>主从多线程模型</li>
</ul>
<p>单线程模型所有工作都在一个线程执行，会由于其中某个handler的阻塞而导致整个服务的阻塞。因此单线程Reactor 模型用的比较少。</p>
<img src="/2018/12/16/netty-start/sp181225_142451.png" title="单线程模型">
<p>多线程模型与单线程模型的区别在于由单独的线程处理accept事件，其它IO操作事件和处理工作放到一组特定的NIO线程来监听处理。Reactor多线程模型如下：</p>
<img src="/2018/12/16/netty-start/sp181225_142801.png" title="多线程模型">
<p>多线程模型改善了handler阻塞对系统的影响，但是对于同时处理大量连接或者在连接时需要进行一些权限检测等工作时，那么单线程处理这些工作仍然负荷较大，可能会影响其它客户端的连接，那么主从多线程则将异步连接事件后续的处理工作也划分到从Reactor线程池来处理，主Reactor线程只负责分配任务。主从Reactor多线程模型如下：</p>
<img src="/2018/12/16/netty-start/sp181225_150212.png" title="主从多线程模型">
<p>那么回头看我们的示例，netty采用的其实就是Reactor多线程模型，bossGroup单线程处理accept事件，workerGroup线程池处理其它工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有了netty模型的基本概念之后，再来细看<code>NioEventLoopGroup</code>和<code>NioEventLoop</code>：</p>
<h3 id="NioEventLoopGroup类层次结构"><a href="#NioEventLoopGroup类层次结构" class="headerlink" title="NioEventLoopGroup类层次结构"></a>NioEventLoopGroup类层次结构</h3><img src="/2018/12/16/netty-start/NioEventLoopGroup.jpg" title="NioEventLoopGroup类层次结构">
<h3 id="NioEventLoopGroup实例化过程"><a href="#NioEventLoopGroup实例化过程" class="headerlink" title="NioEventLoopGroup实例化过程"></a>NioEventLoopGroup实例化过程</h3><p><code>NioEventLoopGroup</code>实例化的序列图中，省略了<code>NioEventLoop</code>的实例化过程，<code>NioEventLoop</code>的实例化后面再单独描述。</p>
<img src="/2018/12/16/netty-start/NioEventLoopGroup实例化.png" title="NioEventLoopGroup实例化">
<p>实例化流程比较简单，只说图中没有明确提到的部分：</p>
<ul>
<li><code>NioEventLoopGroup</code>内部维护了一份类型为<code>EventExecutor</code>的children数组，children数组实际通过<code>newChild()</code>方法创建的实际对象类型是<code>NioEventLoop</code>。</li>
<li>executor存储的是一个<code>ThreadPerTaskExecutor</code>类型的实例，，它实现了<code>execute(Runnable command)</code>接口，只要调用此接口，就会将传入的command作为线程的执行体，通过<code>DefaultThreadFactory.newThread(Runnable r)</code>接口创建线程，并启动线程。而最终此executor会作为参数传递到<code>NioEventLoop</code>中，也就是传递给children数组中的每一个元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadPerTaskExecutor.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        threadFactory.newThread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultThreadFactory.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = newThread(FastThreadLocalRunnable.wrap(r), prefix + nextId.incrementAndGet());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon() != daemon) &#123;</span><br><span class="line">                t.setDaemon(daemon);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != priority) &#123;</span><br><span class="line">                t.setPriority(priority);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">            <span class="comment">// Doesn't matter even if failed to set.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>如果调用构造函数没有设置nThreads数量，则nThreads的数量为<code>DEFAULT_EVENT_LOOP_THREADS</code>，也就是处理器核心数*2</li>
<li>如果nThreads数量是2的次方，则实际通过<code>chooserFactory.newChooser(children)</code>创建的chooser为<code>PowerOfTwoEventExecutorChooser</code>，否则为<code>GenericEventExecutorChooser</code>，这两者的区别在于实现了不同的<code>next</code>方法策略来选择children中的某一个<code>EventExecutor</code>。</li>
</ul>
<h3 id="NioEventLoop类的层次结构"><a href="#NioEventLoop类的层次结构" class="headerlink" title="NioEventLoop类的层次结构"></a>NioEventLoop类的层次结构</h3><p><code>NioEventLoop</code>类的层次结构比较多，重点关注<code>SingleThreadEventExecutor</code>中的thread和executor，它们为<code>NioEventLoop</code>提供了执行线程任务的基础。</p>
<img src="/2018/12/16/netty-start/NioEventLoop.png" title="NioEventLoop类层次结构">
<h3 id="NioEventLoop实例化过程"><a href="#NioEventLoop实例化过程" class="headerlink" title="NioEventLoop实例化过程"></a>NioEventLoop实例化过程</h3><img src="/2018/12/16/netty-start/NioEventLoop实例化.png" title="NioEventLoop实例化">
<p>根据上面的图，再补充解释整个<code>NioEventLoopGroup</code>和<code>NioEventLoop</code>的实例化过程：</p>
<ul>
<li><code>NioEventLoopGroup</code>实例化时，根据传入的需要创建的线程数量，创建了对应数量的<code>NioEventLoop</code>实例，并且最终的executor实例是保存在每一个<code>NioEventLoop</code>实例中。</li>
<li>同样的selectorProvider最终也是传递给<code>NioEventLoop</code>用于创建selector实例，不同的在于selectorProvider只有一份实例。</li>
<li>图中忽略了selector实例的创建，简单描述是selectorProvider会根据操作系统来返回不同平台的selectorProvider，而不同平台的selectorProvider通过实现<code>openSelector()</code>来实例化平台相关的selector。</li>
<li>整个过程<code>SingleThreadEventExecutor</code>的thread属性还没有被赋值，这个属性后面会用到。</li>
</ul>
<h3 id="继续Channel的注册流程"><a href="#继续Channel的注册流程" class="headerlink" title="继续Channel的注册流程"></a>继续Channel的注册流程</h3><p>通过前面五节的介绍，注册函数链式调用<code>group().next()</code>实际通过chooser返回<code>EventExecutor</code>对象也就很容易理解了，其真实意图是在<code>NioEventLoopGroup</code>的chlidren数组中选择一个<code>EventExecutor</code>。也可以认为是返回一个<code>NioEventLoop</code>，它们都在一个继承链上。而<code>NioEventLoop</code>的父类<code>SingleThreadEventLoop</code>实现了<code>register(channel)</code>接口，所以<code>group().next().register(channel)</code>实际最后调用的是<code>SingleThreadEventLoop.register(channel)</code>。调用完成实际的返回值是<code>DefaultChannelPromise</code>，用于保存注册的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SingleThreadEventLoop.java</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line">        promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而<code>SingleThreadEventLoop.register(channel)</code>内部的<code>promise.channel().unsafe().register(this, promise)</code>调用层次很深，我们直接跳过。最终调用到<code>AbstractUnsafe</code>的<code>register</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractUnsafe.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">            register0(promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        register0(promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        <span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,</span><br><span class="line">                        AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">                closeForcibly();</span><br><span class="line">                closeFuture.setClosed();</span><br><span class="line">                safeSetFailure(promise, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>AbstractUnsafe</code>的<code>register</code>方法首先将eventLoop绑定到<code>NioServerSocketChannel</code>上，然后通过<code>eventLoop.inEventLoop</code>方法判断当前线程是否已经处于该事件循环器线程中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractUnsafe.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inEventLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inEventLoop(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SingleThreadEventExecutor.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inEventLoop</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> thread == <span class="keyword">this</span>.thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从代码看，最终判断的依据是<code>SingleThreadEventExecutor</code>的thread属性，也就是我们提到的在<code>NioEventLoop</code>初始化完成后仍然为空的thread。所以此时判断肯定不在同一个线程中。所以最终会执行<code>eventLoop.execute(new Runnable())</code>的分支。</p>
<h3 id="启动第一个新事件监听器线程"><a href="#启动第一个新事件监听器线程" class="headerlink" title="启动第一个新事件监听器线程"></a>启动第一个新事件监听器线程</h3><p>到这里终于进入了一个新的阶段，因为第一个事件监听器线程被创建了。<br>通过<code>NioEventLoop的</code>类的层次结构知道<code>NioEventLoop的</code>是一个<code>Executor</code>,而在<code>SingleThreadEventExecutor</code>中实现了<code>execute</code>接口。<code>eventLoop.execute(new Runnable())</code>调用的实际就是<code>SingleThreadEventExecutor.execute(Runnable task)</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SingleThreadEventExecutor.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">        addTask(task);</span><br><span class="line">        <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">            startThread();</span><br><span class="line">            <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">            wakeup(inEventLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!offerTask(task)) &#123;</span><br><span class="line">            reject(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">offerTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> taskQueue.offer(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    doStartThread();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">                    STATE_UPDATER.set(<span class="keyword">this</span>, ST_NOT_STARTED);</span><br><span class="line">                    PlatformDependent.throwException(cause);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                thread = Thread.currentThread();</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>SingleThreadEventExecutor.execute(Runnable task)</code>首先将task存入taskQueue，也就是将<code>register0</code>操作放入任务队列。接着因为目前还是在主线程调用的execute方法，所以会执行<code>startThread</code>分支。<code>startThread</code>方法又调用了<code>doStartThread</code>分支。</p>
<h3 id="事件监听与处理线程"><a href="#事件监听与处理线程" class="headerlink" title="事件监听与处理线程"></a>事件监听与处理线程</h3><p>继续看<code>doStartThread</code>方法。在<code>doStartThread</code>内部通过executor创建线程并启动线程。前面在<code>NioEventLoopGroup</code>实例化过程中描述了executor如何创建和启动线程。这里再介绍一次：<br>executor存储的是一个<code>ThreadPerTaskExecutor</code>类型的实例。它实现了<code>execute(Runnable command)</code>接口，只要调用此接口，就会将传入的command作为线程的执行体。其内部通过<code>DefaultThreadFactory.newThread(Runnable r)</code>接口创建线程，并启动线程。而executor是会在创建<code>NioEventLoopGroup</code>的children数组元素时，作为参数传递给children数组中的每一个<code>NioEventLoop</code>保存。</p>
<p>因此这里再调用<code>executor.execute(new Runnable())</code>方法时，就会启动一个新的线程，并执行<code>run</code>方法。而<code>run</code>方法内部终于将<code>NioEventLoop</code>的<code>thread</code>字段更新为当前创建的子线程。并最终调用了<code>SingleThreadEventExecutor.this.run()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SingleThreadEventExecutor.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                thread = Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                    thread.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">                updateLastExecutionTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                    success = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                        <span class="keyword">int</span> oldState = state;</span><br><span class="line">                        <span class="keyword">if</span> (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(</span><br><span class="line">                                SingleThreadEventExecutor.<span class="keyword">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Check if confirmShutdown() was called at the end of the loop.</span></span><br><span class="line">                    <span class="keyword">if</span> (success &amp;&amp; gracefulShutdownStartTime == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">                            logger.error(<span class="string">"Buggy "</span> + EventExecutor.class.getSimpleName() + <span class="string">" implementation; "</span> +</span><br><span class="line">                                    SingleThreadEventExecutor.class.getSimpleName() + <span class="string">".confirmShutdown() must "</span> +</span><br><span class="line">                                    <span class="string">"be called before run() implementation terminates."</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// Run all remaining tasks and shutdown hooks.</span></span><br><span class="line">                        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            cleanup();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            STATE_UPDATER.set(SingleThreadEventExecutor.<span class="keyword">this</span>, ST_TERMINATED);</span><br><span class="line">                            threadLock.release();</span><br><span class="line">                            <span class="keyword">if</span> (!taskQueue.isEmpty()) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                                    logger.warn(<span class="string">"An event executor terminated with "</span> +</span><br><span class="line">                                            <span class="string">"non-empty task queue ("</span> + taskQueue.size() + <span class="string">')'</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而<code>SingleThreadEventExecutor</code>本身并没有实现<code>run</code>方法，而是在子类<code>NioEventLoop</code>实现了<code>run</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioEventLoop.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                        select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                            selector.wakeup();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// fall through</span></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cancelledKeys = <span class="number">0</span>;</span><br><span class="line">                needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">                <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                        runAllTasks();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                        runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                handleLoopException(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                    closeAll();</span><br><span class="line">                    <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                handleLoopException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先简单描述当前for循环中完成的供：</p>
<ol>
<li>查询是否有IO事件和任务到来</li>
<li>进行事件处理</li>
<li>进行任务处理</li>
</ol>
<p>下面我们一项项描述。</p>
<h3 id="事件与任务监听"><a href="#事件与任务监听" class="headerlink" title="事件与任务监听"></a>事件与任务监听</h3><p>简单描述<code>selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())</code>这行代码的含义：如果hasTasks() == true, 调用<code>selector.selectNow()</code>，并清空selectionKeys。因为<code>selector.selectNow()</code>的结果肯定&gt;=0，所以会跳出switch块，否则进入<code>case SelectStrategy.SELECT:</code>分支执行<code>select(wakenUp.getAndSet(false))</code>。这样的好处在于当有task来到的时候，只查询就绪的channel，不阻塞线程；当没有task时，则可以执行<code>NioEventLoop.select()</code>函数，此函数如果没有外部中断或者新任务、定时/周期任务等待处理，会循环执行<code>selector.select(timeoutMillis)</code>去检测网络IO事件。</p>
<p>所以当跳出switch块，则表示有IO事件或者任务到达。</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>IO事件到达后，先通过<code>processSelectedKeys()</code>处理IO事件，然后通过<code>runAllTasks</code>处理任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioEventLoop.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">            processSelectedKeysOptimized();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i]</span><br><span class="line"></span><br><span class="line">            selectedKeys.keys[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">                processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">                processSelectedKey(k, task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">                selectedKeys.reset(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                selectAgain();</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>selectedKeys</code>在前面创建<code>NioEventLoop</code>已经初始化过了，所以会调用<code>processSelectedKeysOptimized()</code>函数，但此时第一次进入此函数时<code>selectedKeys</code>是空的，因此直接返回，不处理任何的网络IO事件。<br>虽然目前<code>selectedKeys</code>为空，但还是看看当<code>selectedKeys</code>存储了对应的IO事件时，做了些什么工作：</p>
<ul>
<li><p>首先通过<code>selectedKeys.keys[i] = null;</code>清除网络IO事件，然后通过<code>processSelectedKey()</code>处理网络事件和附加的数据a，数据a可以转换为一个<code>AbstractNioChannel</code>或者<code>NioTask&lt;SelectableChannel&gt;</code>。</p>
</li>
<li><p>如果附加的是<code>AbstractNioChannel</code>类型的数据，那么最终<code>processSelectedKey</code>会根据具体的IO事件，通过channel的Unsafe接口去执行具体的读、写、处理连接等工作。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioEventLoop.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">                ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">                unsafe.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">                ch.unsafe().forceFlush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">                unsafe.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">            unsafe.close(unsafe.voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>而如果附加的是<code>NioTask&lt;SelectableChannel&gt;</code>类型的数据，那么<code>processSelectedKey</code>则通过<code>NioTask&lt;SelectableChannel&gt;</code>的<code>channelReady</code>接口完成具体的后续操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NioEventLoop.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, NioTask&lt;SelectableChannel&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            task.channelReady(k.channel(), k);</span><br><span class="line">            state = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            k.cancel();</span><br><span class="line">            invokeChannelUnregistered(task, k, e);</span><br><span class="line">            state = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                k.cancel();</span><br><span class="line">                invokeChannelUnregistered(task, k, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (!k.isValid()) &#123; <span class="comment">// Cancelled by channelReady()</span></span><br><span class="line">                    invokeChannelUnregistered(task, k, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="任务处理"><a href="#任务处理" class="headerlink" title="任务处理"></a>任务处理</h3><p>完成IO事件的处理后，继续往下执行<code>runAllTasks</code>。在处理任务时，需要根据<code>this.ioRatio</code>成员变量控制处理任务的时间百分比。<code>this.ioRatio</code>的默认值为50。也就是说，在事件循环中默认情况下用于处理I/O操作的时间和用于处理任务的时间百分比都为50%。<br>这里我们先看当ioRatio为100的时候是如何执行的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SingleThreadEventExecutor.java</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">boolean</span> fetchedAll;</span><br><span class="line">        <span class="keyword">boolean</span> ranAtLeastOne = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            fetchedAll = fetchFromScheduledTaskQueue();</span><br><span class="line">            <span class="keyword">if</span> (runAllTasksFrom(taskQueue)) &#123;</span><br><span class="line">                ranAtLeastOne = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!fetchedAll); <span class="comment">// keep on processing until we fetched all scheduled tasks.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ranAtLeastOne) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        afterRunningAllTasks();</span><br><span class="line">        <span class="keyword">return</span> ranAtLeastOne;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fetchFromScheduledTaskQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nanoTime = AbstractScheduledEventExecutor.nanoTime();</span><br><span class="line">        Runnable scheduledTask  = pollScheduledTask(nanoTime);</span><br><span class="line">        <span class="keyword">while</span> (scheduledTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!taskQueue.offer(scheduledTask)) &#123;</span><br><span class="line">                <span class="comment">// No space left in the task queue add it back to the scheduledTaskQueue so we pick it up again.</span></span><br><span class="line">                scheduledTaskQueue().add((ScheduledFutureTask&lt;?&gt;) scheduledTask);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            scheduledTask  = pollScheduledTask(nanoTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">runAllTasksFrom</span><span class="params">(Queue&lt;Runnable&gt; taskQueue)</span> </span>&#123;</span><br><span class="line">        Runnable task = pollTaskFrom(taskQueue);</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            safeExecute(task);</span><br><span class="line">            task = pollTaskFrom(taskQueue);</span><br><span class="line">            <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>runAllTasks()</code>方法通过<code>fetchFromScheduledTaskQueue()</code>方法将所有即将到达执行时间点的周期定时任务从<code>scheduledTaskQueue</code>取出，放到<code>taskQueue</code>中，然后通过<code>runAllTasksFrom(Queue&lt;Runnable&gt; taskQueue)</code>将所有任务一个个取出并执行。这里的循环不会被打断，也就意味着直到所有任务执行完成才会退出。</p>
<p>下面看一下<code>runAllTasks(long timeoutNanos)</code>方法的实现，这也是当前流程中执行的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SingleThreadEventExecutor.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">(<span class="keyword">long</span> timeoutNanos)</span> </span>&#123;</span><br><span class="line">        fetchFromScheduledTaskQueue();</span><br><span class="line">        Runnable task = pollTask();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            afterRunningAllTasks();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</span><br><span class="line">        <span class="keyword">long</span> runTasks = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> lastExecutionTime;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            safeExecute(task);</span><br><span class="line"></span><br><span class="line">            runTasks ++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check timeout every 64 tasks because nanoTime() is relatively expensive.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">XXX:</span> Hard-coded value - will make it configurable if it is really a problem.</span></span><br><span class="line">            <span class="keyword">if</span> ((runTasks &amp; <span class="number">0x3F</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            task = pollTask();</span><br><span class="line">            <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">                lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        afterRunningAllTasks();</span><br><span class="line">        <span class="keyword">this</span>.lastExecutionTime = lastExecutionTime;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>runAllTasks(long timeoutNanos)</code>首先将所有即将到达执行时间点的周期定时任务从<code>scheduledTaskQueue</code>取出，放到<code>taskQueue</code>中，目前还没有定时和周期任务。然后也会从<code>taskQueue</code>取出每一个task去执行，但是每取出64个（0x100）之后，会进行一次超时判断，如果超时则退出任务的执行。目前<code>taskQueue</code>中存放了一个执行<code>register0</code>方法的任务，所以此任务会出去来准备执行。</p>
<h3 id="切换到子线程继续完成注册"><a href="#切换到子线程继续完成注册" class="headerlink" title="切换到子线程继续完成注册"></a>切换到子线程继续完成注册</h3><p>当<code>runAllTasks</code>方法内部执行到<code>safeExecute(task)</code>方法时，会调用<code>task.run()</code>方法执行任务的实际工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractEventExecutor.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">safeExecute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"A task raised an exception. Task: &#123;&#125;"</span>, task, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所以<code>task.run</code>方法此时执行的就是<code>register0(promise)</code>，它是在channel注册时提交的task。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannel.java</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                register0(promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此<code>register0</code>方法实际是在子线程中执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractChannel.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// check if the channel is still open as it could be closed in the mean time when the register</span></span><br><span class="line">            <span class="comment">// call was outside of the eventLoop</span></span><br><span class="line">            <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">            doRegister();</span><br><span class="line">            neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">            registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span></span><br><span class="line">            <span class="comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span></span><br><span class="line">            pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">            safeSetSuccess(promise);</span><br><span class="line">            pipeline.fireChannelRegistered();</span><br><span class="line">            <span class="comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span></span><br><span class="line">            <span class="comment">// multiple channel actives if the channel is deregistered and re-registered.</span></span><br><span class="line">            <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                    pipeline.fireChannelActive();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                    <span class="comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span></span><br><span class="line">                    <span class="comment">// again so that we process inbound data.</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// See https://github.com/netty/netty/issues/4805</span></span><br><span class="line">                    beginRead();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Close the channel directly to avoid FD leak.</span></span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个方法完成了几个动作：</p>
<ul>
<li><code>promise.setUncancellable()</code>设置注册这个异步操作的promise状态为不可取消的(UNCANCELLABLE)。</li>
<li>通过<code>doRegister</code>方法完成<code>Selector</code>和<code>Channel</code>的绑定。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractNioChannel.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SelectableChannel <span class="title">javaChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>javaChannel()</code>接口获取的ch，在<code>NioServerSocketChannel</code>初始化时，创建的实例是<code>ServerSocketChannelImpl</code>，并且已经设置为非阻塞模式。只要调用<code>SelectableChannel</code>的<code>register</code>接口就可以完成注册并返回对应的<code>SelectionKey</code>对象。而实际<code>register</code>方法是在其父类<code>AbstractSelectableChannel</code>中实现，传入的参数为当前<code>NioEventLoop</code>的<code>Selector</code>和<code>Channel</code>实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractSelectableChannel.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Object att)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">            <span class="keyword">if</span> ((ops &amp; ~validOps()) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            <span class="keyword">if</span> (blocking)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line">            SelectionKey k = findKey(sel);</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line">                k.attach(att);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// New registration</span></span><br><span class="line">                <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">                    k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att);</span><br><span class="line">                    addKey(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>AbstractSelectableChannel.register(Selector sel, int ops, Object att)</code>方法会判断当前的<code>Selector</code>是否已经注册过，如果注册过则将新的监听事件和新的<code>SelectableChannel</code>实例附加到当前的<code>Selector</code>实例中。但是当前我们的<code>Selector</code>还没有注册过，因此执行的分支是调用<code>((AbstractSelector)sel).register(this, ops, att)</code>方法，也就是调用<code>Selector</code>实例的注册方法。而<code>SelectorImpl</code>实现了此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SelectorImpl.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(AbstractSelectableChannel var1, <span class="keyword">int</span> var2, Object var3)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        SelectionKeyImpl var4 = <span class="keyword">new</span> SelectionKeyImpl((SelChImpl)var1, <span class="keyword">this</span>);</span><br><span class="line">        var4.attach(var3);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        var4.interestOps(var2);</span><br><span class="line">        <span class="keyword">return</span> var4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此方法将<code>Selector</code>和<code>SelectableChannel</code>绑定，设置监听事件，并将this(也就是<code>NioServerSocketChannel</code>)作为附加属性设置到<code>SelectionKey</code>中。</p>
<ul>
<li>将成员变量registered置为true，表示<code>Channel</code>已经在当前<code>NioEventLoop</code>线程中完成注册。</li>
<li>为注册好的channel的pipeline增加预先定义好的handler，并将下一步要执行的任务添加到<code>NioEventLoop</code>的事件队列。下面开始分析这一系列动作：执行<code>pipeline.invokeHandlerAddedIfNeeded()</code>将在channel初始化时存入链表的<code>PendingHandlerAddedTask</code>取出，并执行其<code>execute()</code>方法，方法会调用<code>ctx.handler().handlerAdded(ctx);</code>，<code>handler()</code>获取到的就是重写了<code>initChannel</code>方法的<code>ChannelInitializer&lt;Channel&gt;</code>的实例，而最终<code>handlerAdded(ctx);</code>就会调用到重写的<code>initChannel</code>方法。这些我们在前面<code>NioServerSocketChannel</code>初始化章节的最后描述过。重写的<code>initChannel</code>方法先将<code>ServerBootstrap</code>中保存的handler加入到pipeline的双向链表中，然后再将一个新的task加入到eventLoop的任务队列中，并会在下一次查询任务队列时被执行。这个任务的作用就是将一个新的handler加入到pipeline的双向链表中。这个handler的类型是<code>ServerBootstrapAcceptor</code>，具体的作用我们等到bind操作完成之后再说。等到将<code>initChannel</code>方法执行完毕之后，这个<code>ChannelInitializer</code>handler会将自己从pipeline中移除，并将ChannelInitializer关联的ChannelHandlerContext的状态置为REMOVE_COMPLETE。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ChannelInitializer.java</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">                initChannel(ctx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        initChannel((C) ctx.channel());</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        remove(ctx);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServerBootstrap.java</span></span><br><span class="line"></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>标志<code>ChannelPromise</code>(也就是<code>DefaultChannelPromise</code>对象)为成功，也就是将注册这个异步操作标志为成功。</p>
</li>
<li><p><code>pipeline.fireChannelRegistered()</code>触发<code>ChannelRegistered</code>事件，该事件会在<code>ChannelPipeline</code>中传播。它会先被head处理，随后该事件通过<code>ChannelHandlerContext</code>来实现传递给<code>ChannelPipeline</code>中的下一个<code>ChannelInboundHandler</code>处理器处理，直到最后被tail所处理。<br>到这里<code>initAndRegister()</code>函数执行完毕，意味着channel的注册和初始化完成了。</p>
</li>
</ul>
<h3 id="回到主线程的dobind"><a href="#回到主线程的dobind" class="headerlink" title="回到主线程的dobind()"></a>回到主线程的dobind()</h3><p>回到主线程的<code>dobind()</code>函数，我们一开始就说过，注册这个异步操作根据结果存在两个分支，注册成功直接调用<code>doBind0</code>，否则通过<code>addListener</code>的方式异步执行<code>dobind0</code>。其实只要看注册未完成情况下的分支就可以了。<code>regFuture.addListener</code>创建了一个重写<code>operationComplete</code>接口的<code>ChannelFutureListener</code>。<code>operationComplete()</code>会在regFuture异步操作完成时收到通知。到这里主线程<code>bind()</code>操作完成后，执行<code>sync()</code>阻塞等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBootstrap.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">            ChannelPromise promise = channel.newPromise();</span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">            regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    Throwable cause = future.cause();</span><br><span class="line">                    <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        promise.setFailure(cause);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        promise.registered();</span><br><span class="line"></span><br><span class="line">                        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="bossGroup线程继续bind0工作"><a href="#bossGroup线程继续bind0工作" class="headerlink" title="bossGroup线程继续bind0工作"></a>bossGroup线程继续bind0工作</h3><p>回到<code>bossGroup</code>子线程，往回看<code>register0</code>函数内部的第5个步骤：<br>设置promise为注册成功状态<code>safeSetSuccess(promise);</code>。<br>到这里主线程创建的<code>ChannelFutureListener</code>在此时就会直接在<code>bossGroup</code>子线程内执行<code>operationComplete</code>接口，执行<code>bind0</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBootstrap.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                    channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.setFailure(regFuture.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>bind0</code>将channel的bind操作加入到任务队列中。</p>
<h3 id="NioEventLoop线程继续执行任务队列"><a href="#NioEventLoop线程继续执行任务队列" class="headerlink" title="NioEventLoop线程继续执行任务队列"></a>NioEventLoop线程继续执行任务队列</h3><p>到这里，我们的NioEventLoop任务队列又多了两个任务：</p>
<ol>
<li>将<code>ServerBootstrapAcceptor</code>加入到pipeline双向链表中</li>
<li>执行<code>channel.bind</code>操作完成channel端口的绑定</li>
</ol>
<h3 id="任务一：ServerBootstrapAcceptor实现事件分派"><a href="#任务一：ServerBootstrapAcceptor实现事件分派" class="headerlink" title="任务一：ServerBootstrapAcceptor实现事件分派"></a>任务一：ServerBootstrapAcceptor实现事件分派</h3><p>先看第一个任务天下的handler。<code>ServerBootstrapAcceptor</code>在<code>channelRead</code>事件触发的时候，把<code>childHandler</code>加到<code>childChannel</code>的Pipeline，设置<code>childChannel</code>的<code>options</code>和<code>attrs</code>，最后执行<code>childChannel</code>的注册来绑定<code>workerGroup</code>的<code>NioEventLoop</code>，并启动<code>workerGroup</code>的事件监听线程。通过这种方式把已经连接的channel的后续IO事件分派给<code>workerGroup</code>进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServerBootstrap.java</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrapAcceptor</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup childGroup;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler childHandler;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable enableAutoReadTask;</span><br><span class="line"></span><br><span class="line">        ServerBootstrapAcceptor(</span><br><span class="line">                <span class="keyword">final</span> Channel channel, EventLoopGroup childGroup, ChannelHandler childHandler,</span><br><span class="line">                Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions, Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs) &#123;</span><br><span class="line">            <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">            <span class="keyword">this</span>.childHandler = childHandler;</span><br><span class="line">            <span class="keyword">this</span>.childOptions = childOptions;</span><br><span class="line">            <span class="keyword">this</span>.childAttrs = childAttrs;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Task which is scheduled to re-enable auto-read.</span></span><br><span class="line">            <span class="comment">// It's important to create this Runnable before we try to submit it as otherwise the URLClassLoader may</span></span><br><span class="line">            <span class="comment">// not be able to load the class because of the file limit it already reached.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/1328</span></span><br><span class="line">            enableAutoReadTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    channel.config().setAutoRead(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">            child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">            setChannelOptions(child, childOptions, logger);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">                child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                            forceClose(child, future.cause());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                forceClose(child, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forceClose</span><span class="params">(Channel child, Throwable t)</span> </span>&#123;</span><br><span class="line">            child.unsafe().closeForcibly();</span><br><span class="line">            logger.warn(<span class="string">"Failed to register an accepted channel: &#123;&#125;"</span>, child, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelConfig config = ctx.channel().config();</span><br><span class="line">            <span class="keyword">if</span> (config.isAutoRead()) &#123;</span><br><span class="line">                <span class="comment">// stop accept new connections for 1 second to allow the channel to recover</span></span><br><span class="line">                <span class="comment">// See https://github.com/netty/netty/issues/1328</span></span><br><span class="line">                config.setAutoRead(<span class="keyword">false</span>);</span><br><span class="line">                ctx.channel().eventLoop().schedule(enableAutoReadTask, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// still let the exceptionCaught event flow through the pipeline to give the user</span></span><br><span class="line">            <span class="comment">// a chance to do something with it</span></span><br><span class="line">            ctx.fireExceptionCaught(cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="任务二：服务器执行bind操作"><a href="#任务二：服务器执行bind操作" class="headerlink" title="任务二：服务器执行bind操作"></a>任务二：服务器执行bind操作</h3><p>取出的第二个任务执行channel.bind完成了端口绑定，并增加了<code>ChannelFutureListener.CLOSE_ON_FAILURE</code>监听器监听关闭失败的结果。到这里，整个服务器的启动工作就全部完成了。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
			<a href="/tags/java/" <i="" class="fa fa-tag"> java</a>
          
			<a href="/tags/netty/" <i="" class="fa fa-tag"> netty</a>
          
			<a href="/tags/服务器/" <i="" class="fa fa-tag"> 服务器</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/15/raspberry-autoconfig/" rel="next" title="树莓派开发环境自动配置脚本">
                <i class="fa fa-chevron-left"></i> 树莓派开发环境自动配置脚本
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/03/ble-theory/" rel="prev" title="ble基础与ble协议栈">
                ble基础与ble协议栈 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/7.jpg" alt="photosyn">
            
              <p class="site-author-name" itemprop="name">photosyn</p>
              <p class="site-description motion-element" itemprop="description">学习，生活</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://photosyn.github.io" title="GitHub &rarr; https://photosyn.github.io" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#ServerBootStrap示例"><span class="nav-number">1.</span> <span class="nav-text">ServerBootStrap示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路"><span class="nav-number">2.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#整体启动脉络"><span class="nav-number">3.</span> <span class="nav-text">整体启动脉络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#netty启动相关类介绍"><span class="nav-number">4.</span> <span class="nav-text">netty启动相关类介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器的启动入口"><span class="nav-number">5.</span> <span class="nav-text">服务器的启动入口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#initAndRegister方法"><span class="nav-number">5.1.</span> <span class="nav-text">initAndRegister方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#确定创建的channel类型"><span class="nav-number">6.</span> <span class="nav-text">确定创建的channel类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NioServerSocketChannel扩展理解"><span class="nav-number">7.</span> <span class="nav-text">NioServerSocketChannel扩展理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractChannel核心类介绍"><span class="nav-number">8.</span> <span class="nav-text">AbstractChannel核心类介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractNioChannel核心类介绍"><span class="nav-number">9.</span> <span class="nav-text">AbstractNioChannel核心类介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NioServerSocketChannel核心类介绍"><span class="nav-number">10.</span> <span class="nav-text">NioServerSocketChannel核心类介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NioServerSocketChannel的类图"><span class="nav-number">11.</span> <span class="nav-text">NioServerSocketChannel的类图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建NioServerSocketChannel"><span class="nav-number">12.</span> <span class="nav-text">创建NioServerSocketChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pipeline的创建"><span class="nav-number">13.</span> <span class="nav-text">pipeline的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NioServerSocketChannel的初始化"><span class="nav-number">14.</span> <span class="nav-text">NioServerSocketChannel的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NioServerSocketChannel注册入口"><span class="nav-number">15.</span> <span class="nav-text">NioServerSocketChannel注册入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reactor模型的理解"><span class="nav-number">16.</span> <span class="nav-text">Reactor模型的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NioEventLoopGroup类层次结构"><span class="nav-number">17.</span> <span class="nav-text">NioEventLoopGroup类层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NioEventLoopGroup实例化过程"><span class="nav-number">18.</span> <span class="nav-text">NioEventLoopGroup实例化过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NioEventLoop类的层次结构"><span class="nav-number">19.</span> <span class="nav-text">NioEventLoop类的层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NioEventLoop实例化过程"><span class="nav-number">20.</span> <span class="nav-text">NioEventLoop实例化过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继续Channel的注册流程"><span class="nav-number">21.</span> <span class="nav-text">继续Channel的注册流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动第一个新事件监听器线程"><span class="nav-number">22.</span> <span class="nav-text">启动第一个新事件监听器线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件监听与处理线程"><span class="nav-number">23.</span> <span class="nav-text">事件监听与处理线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件与任务监听"><span class="nav-number">24.</span> <span class="nav-text">事件与任务监听</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件处理"><span class="nav-number">25.</span> <span class="nav-text">事件处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务处理"><span class="nav-number">26.</span> <span class="nav-text">任务处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切换到子线程继续完成注册"><span class="nav-number">27.</span> <span class="nav-text">切换到子线程继续完成注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回到主线程的dobind"><span class="nav-number">28.</span> <span class="nav-text">回到主线程的dobind()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bossGroup线程继续bind0工作"><span class="nav-number">29.</span> <span class="nav-text">bossGroup线程继续bind0工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NioEventLoop线程继续执行任务队列"><span class="nav-number">30.</span> <span class="nav-text">NioEventLoop线程继续执行任务队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务一：ServerBootstrapAcceptor实现事件分派"><span class="nav-number">31.</span> <span class="nav-text">任务一：ServerBootstrapAcceptor实现事件分派</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务二：服务器执行bind操作"><span class="nav-number">32.</span> <span class="nav-text">任务二：服务器执行bind操作</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">photosyn</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>








        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>




  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  
  





  

  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('2');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  
  <script src="/js/src/js.cookie.js?v=6.7.0"></script>
  <script src="/js/src/scroll-cookie.js?v=6.7.0"></script>


  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":80,"height":160,"hOffset":0,"vOffset":-20},"mobile":{"show":false},"log":false});</script></body>
</html>
